<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计原则</title>
      <link href="/2023/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2023/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>面向对象的7大设计原则是：</p><ol><li><p>单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起变化的原因。换句话说，一个类应该只负责一项职责。</p></li><li><p>开放封闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。也就是说，当需要改变一个软件实体的行为时，应该通过扩展该实体的行为而不是修改它的源代码。</p></li><li><p>里氏替换原则（Liskov Substitution Principle，LSP）：子类必须能够替换掉父类并且不会影响程序的正确性。也就是说，任何基类可以被其子类替换而不影响程序的正确性。</p></li><li><p>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，而是应该依赖于抽象。也就是说，模块之间的依赖关系应该通过抽象来建立。</p></li><li><p>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖于它不需要的接口。也就是说，一个类不应该强迫其客户端实现它们不需要的方法。</p></li><li><p>迪米特法则（Law of Demeter，LoD）：一个对象应该对其他对象有尽可能少的了解。也就是说，一个对象不应该直接与其他对象交互，而是通过中介对象来进行通信。</p></li><li><p>合成复用原则（Composite Reuse Principle，CRP）：尽量使用对象组合，而不是继承来达到代码复用的目的。也就是说，通过将对象组合在一起来实现新的功能，而不是通过继承来获得新的功能。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2023/10/18/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/18/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/10/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<img src="/2023/10/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" class><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&emsp;&emsp;快速排序（Quick Sort）是一种常用的排序算法，它的基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>快速排序的具体步骤如下：</p><ol><li><p>选择一个基准元素（通常是待排序数据的第一个元素）。</p></li><li><p>将数据分成两部分，所有比基准元素小的放在基准元素的左边，所有比基准元素大的放在基准元素的右边。</p></li><li><p>对左右两部分分别进行快速排序，直到每个部分只剩下一个元素或为空。</p></li><li><p>将左半部分、基准元素、右半部分依次连接起来，得到有序序列。</p></li></ol><p>&emsp;&emsp;快速排序的关键在于选择合适的基准元素和分割的策略。常见的分割策略有：挖坑法、指针交换法、前后指针法等。</p><p>&emsp;&emsp;快速排序的平均时间复杂度为O(nlogn)，是一种高效的排序算法。然而，快速排序是一种不稳定的排序算法，即相等元素的相对顺序可能会改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>&emsp;&emsp;归并排序（Merge Sort）是一种经典的排序算法，它的基本思想是将待排序的数据分成两个子序列，分别对这两个子序列进行递归排序，然后将两个有序的子序列合并成一个有序的序列。</p><p>归并排序的具体步骤如下：</p><ol><li><p>将待排序的数据分成两个子序列，通常是将数据分成两半。</p></li><li><p>对每个子序列进行递归排序，直到子序列只剩下一个元素或为空。</p></li><li><p>将两个有序的子序列合并成一个有序的序列。具体的合并方法是比较两个子序列的第一个元素，将较小的元素放入新的序列中，然后将对应子序列的指针向后移动一位，重复这个过程，直到其中一个子序列为空，然后将另一个子序列的剩余元素依次放入新的序列中。</p></li><li><p>得到的新序列即为有序序列。</p></li></ol><p>&emsp;&emsp;归并排序的时间复杂度为O(nlogn)，是一种稳定的排序算法。它的主要缺点是需要额外的空间来存储临时序列，因此在排序大量数据时，需要考虑内存的使用情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见排序算法稳定性及复杂度"><a href="#常见排序算法稳定性及复杂度" class="headerlink" title="常见排序算法稳定性及复杂度"></a>常见排序算法稳定性及复杂度</h2><img src="/2023/10/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20210327002454253.png" class>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2023/10/18/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/18/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p>爬楼梯：假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">46</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        num[i] = num[i<span class="number">-1</span>] + num[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小花费爬楼梯：给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>* cost, <span class="type">int</span> costSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = minNum(dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打家劫舍：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = maxNum(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            dp[i] = maxNum(dp[i<span class="number">-2</span>] + nums[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[numsSize<span class="number">-1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除并获得点数：给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bobble_sort</span><span class="params">(<span class="type">int</span> *num, <span class="type">int</span> numSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &lt; num[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            num[i] ^= num[i<span class="number">-1</span>];</span><br><span class="line">            num[i<span class="number">-1</span>] ^= num[i];</span><br><span class="line">            num[i] ^= num[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num[numSize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;   </span><br><span class="line">    <span class="type">int</span> weight[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> weiSize = bobble_sort(nums, numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        weight[nums[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">1</span>] = weight[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; weiSize+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i] = maxNum(dp[i<span class="number">-2</span>] + weight[i] * i, dp[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[weiSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>和可被k整除的子数组：给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p><p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">subarraysDivByK</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pix = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10001</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pix += nums[i];</span><br><span class="line">        pix %= k;</span><br><span class="line">        <span class="keyword">if</span>(pix &lt; <span class="number">0</span>) pix += k;</span><br><span class="line">        result += arr[pix];</span><br><span class="line">        ++arr[pix];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinuxIO操作</title>
      <link href="/2023/10/10/Linux/LinuxIO%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/10/Linux/LinuxIO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>&emsp;&emsp;在Linux中，有一句经典的话叫做：”一切皆文件“。这句话是站在内核的角度说的，因为在内核中所有的设备（出了网络接口）都一律使用Linux独有的虚拟文件系统（VFS）来管理。这样做的最终目的，是将各种不同的设备用“文件”这个概念加以封装和屏蔽，简化应用层编程的难度。文件，是Linux系统最重要的两个抽象概念之一（另一个是进程）。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>下图是Linux中的文件系统结构</p><img src="/2023/10/10/Linux/LinuxIO%E6%93%8D%E4%BD%9C/v2-034fad7f4ad53eddb14aeca5c63b6cc0_r.jpg" class><ul><li>根目录（&#x2F;）：根目录是整个文件系统的顶级目录，所有其他目录和文件都是从根目录开始的。在Linux中，根目录用斜杠（&#x2F;）表示。</li><li><code>/bin</code>：&#x2F;bin目录包含一些基本的可执行文件，这些文件是系统启动和运行所必需的。例如，&#x2F;bin目录包含常用的命令如ls、cp、rm等。</li><li><code>/boot</code>：&#x2F;boot目录包含启动加载程序（bootloader）的相关文件，包括内核映像文件和引导配置文件。在启动过程中，系统会使用&#x2F;boot目录下的文件来引导操作系统。</li><li><code>/dev</code>：&#x2F;dev目录包含设备文件，这些文件用于与系统中的设备进行交互。在Linux中，一切都被视为文件，设备文件用于访问硬件设备，如磁盘、键盘、鼠标等。</li><li><code>/etc</code>：&#x2F;etc目录包含系统的配置文件。这些配置文件用于设置系统的各种参数和选项，例如网络配置、用户账户配置、服务配置等。&#x2F;etc目录中的文件对系统的正常运行至关重要。</li><li><code>/home</code>：&#x2F;home目录是用户的主目录，每个用户都有一个与其用户名相对应的子目录。用户可以在自己的主目录中存储个人文件和配置。</li><li><code>/lib</code> 和 <code>/lib64</code>：&#x2F;lib目录和&#x2F;lib64目录包含共享库文件，这些库文件是应用程序和系统工具所需的共享组件。&#x2F;lib目录用于32位系统，而&#x2F;lib64目录用于64位系统。</li><li><code>/media</code>：&#x2F;media目录用于挂载可移动设备，如光盘、USB驱动器等。当插入可移动设备时，系统会自动将其挂载到&#x2F;media目录下的子目录中。</li><li><code>/mnt</code>：&#x2F;mnt目录用于临时挂载其他文件系统或网络共享。管理员可以将其他设备或远程共享挂载到&#x2F;mnt目录中，以便访问其内容。</li><li><code>/opt</code>：&#x2F;opt目录用于安装第三方软件包。一些应用程序将其安装在&#x2F;opt目录下，以便与系统的其他部分分离。</li><li><code>/proc</code>：&#x2F;proc目录是一个虚拟文件系统，提供有关系统和进程的信息。系统管理员和开发人员可以通过读取&#x2F;proc目录下的文件来获取关于系统状态、进程信息、硬件配置等的实时数据。</li><li><code>/root</code>：&#x2F;root目录是超级用户（root用户）的主目录。与普通用户的主目录（&#x2F;home）不同，超级用户的主目录位于&#x2F;root。只有root用户可以访问和操作&#x2F;root目录。</li><li><code>/sbin</code>：&#x2F;sbin目录包含系统管理员使用的一些系统命令和工具。这些命令和工具通常用于系统管理和维护任务，例如启动和停止服务、网络配置等。</li><li><code>/srv</code>：&#x2F;srv目录用于存储系统服务提供的数据。例如，Web服务器可以将网站数据存储在&#x2F;srv目录下。</li><li><code>/tmp</code>：&#x2F;tmp目录用于存储临时文件。该目录中的文件通常在系统重新启动后被删除。应注意定期清理&#x2F;tmp目录，以确保不会占用过多的磁盘空间。</li><li><code>/usr</code>：&#x2F;usr目录包含用户的应用程序和文件。这是Linux系统中最大的目录之一，它通常包含共享的可执行文件、库文件、文档、图标等。</li><li><code>/var</code>：&#x2F;var目录用于存储可变数据，例如日志文件、缓存文件和临时文件。&#x2F;var目录中的数据通常在系统运行时会频繁变化。</li><li><code>/run</code>：&#x2F;run目录是一个临时文件系统，用于存储在系统引导过程中需要保存的运行时数据。例如，PID文件、锁文件等。</li><li><code>/run/user</code>：&#x2F;run&#x2F;user目录包含与用户相关的运行时数据。每个用户都有一个与其用户ID相对应的子目录，用于存储用户特定的运行时数据。</li><li><code>/sys</code>：&#x2F;sys目录是一个虚拟文件系统，用于提供关于系统硬件和设备的信息。它是与&#x2F;sys目录下的文件进行交互的一种方法。</li><li><code>/srv</code>：&#x2F;srv目录用于存储系统服务提供的数据。例如，Web服务器可以将网站数据存储在&#x2F;srv目录下。</li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>目录文件（d）</li><li>字符设备文件（c）</li><li>块设备文件（b）</li><li>有名管道（p）</li><li>套接字文件（s）</li><li>符号连接文件（l）</li></ul><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>&emsp;&emsp;Linux文件I&#x2F;O是指在Linux操作系统中对文件进行输入和输出操作的过程。Linux提供了一套强大且灵活的文件I&#x2F;O接口，使得开发者可以通过文件来进行数据的读取、写入和操作。</p><p>&emsp;&emsp;在Linux中，文件被视为一系列字节的有序集合。每个文件都有一个唯一的文件描述符（file descriptor），用于标识该文件。文件描述符是一个非负整数，通常是一个小的非负整数。它是用来在进程中引用打开的文件的。</p><blockquote><p>在一个程序刚运行时，会自动打开三个文件 <code>/dev/stdin</code>、<code>/dev/stdout</code>、<code>/dev/stderr</code> 他们分别占用 0，1，2 这三个文件描述符，所以之后打开的文件的文件描述符是从3开始。</p></blockquote><p>以下是一些常用的文件I&#x2F;O函数（函数的具体用法请查阅man手册）：</p><table><thead><tr><th align="center">函数名</th><th align="center">作 用</th></tr></thead><tbody><tr><td align="center">open</td><td align="center">打开一个文件，并返回一个文件描述符</td></tr><tr><td align="center">close</td><td align="center">关闭一个已打开的文件</td></tr><tr><td align="center">read</td><td align="center">从文件中读取数据，并存储到缓冲区中</td></tr><tr><td align="center">write</td><td align="center">将数据写入文件</td></tr><tr><td align="center">lseek</td><td align="center">设置文件偏移量，用于定位文件中的位置</td></tr><tr><td align="center">fcntl</td><td align="center">对文件描述符进行控制，如设置文件状态标志、获取文件状态等</td></tr><tr><td align="center">dup</td><td align="center">复制一个文件描述符</td></tr><tr><td align="center">dup2</td><td align="center">将一个文件描述符复制到另一个指定的文件描述符</td></tr><tr><td align="center">pipe</td><td align="center">创建一个管道，用于进程间通信</td></tr><tr><td align="center">ioctl</td><td align="center">对设备进行控制，如设置设备参数、获取设备状态等</td></tr><tr><td align="center">flock</td><td align="center">对文件进行加锁或解锁</td></tr></tbody></table><p>&emsp;&emsp;这些函数提供了基本的文件I&#x2F;O操作，可以用于打开、读取、写入和关闭文件。此外，还有一些其他的文件I&#x2F;O函数，如pread()、pwrite()、stat()、fstat()、access()等，用于更高级的文件操作。</p><p>&emsp;&emsp;需要注意的是，在使用这些文件I&#x2F;O函数时，需要正确处理错误，并及时关闭文件以释放资源。此外，还需要注意文件的权限、并发访问和文件锁等问题，以确保文件的安全和正确性。</p><h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><p>&emsp;&emsp;Linux标准I&#x2F;O是一组用于文件输入和输出的函数，它们构建在Linux系统调用的基础上，提供了更高级别的接口和功能。标准I&#x2F;O函数包括stdio.h头文件中定义的函数。</p><p>&emsp;&emsp;标准I&#x2F;O函数提供了一种更方便和易于使用的方式来进行文件读写操作，相对于直接使用系统调用，它们更加灵活和高级。标准I&#x2F;O函数可以通过缓冲区来提高性能，可以按行读取和写入文件，可以进行格式化的输入和输出等。</p><img src="/2023/10/10/Linux/LinuxIO%E6%93%8D%E4%BD%9C/%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.png" class><p>以下是一些常用的标准I&#x2F;O函数（函数的具体用法请查阅man手册）：</p><table><thead><tr><th align="center">函数名</th><th align="center">作 用</th></tr></thead><tbody><tr><td align="center">fopen</td><td align="center">打开文件并返回一个文件指针</td></tr><tr><td align="center">freopen</td><td align="center">重定向输出</td></tr><tr><td align="center">fclose</td><td align="center">关闭文件</td></tr><tr><td align="center">fgetc</td><td align="center">从文件中读取一个字符</td></tr><tr><td align="center">fgets</td><td align="center">从文件中读取一行</td></tr><tr><td align="center">fputc</td><td align="center">将一个字符写入文件</td></tr><tr><td align="center">fputs</td><td align="center">将一行字符串写入文件</td></tr><tr><td align="center">fprintf</td><td align="center">格式化输出到文件</td></tr><tr><td align="center">fscanf</td><td align="center">从文件中格式化输入</td></tr><tr><td align="center">fseek</td><td align="center">设置文件位置指针的位置</td></tr><tr><td align="center">ftell</td><td align="center">获取文件位置指针的当前位置</td></tr></tbody></table><p>&emsp;&emsp;标准I&#x2F;O函数与系统调用函数之间存在一些差异。标准I&#x2F;O函数使用文件指针来引用打开的文件，而系统调用函数使用文件描述符。标准I&#x2F;O函数使用缓冲区来提高性能，而系统调用函数则直接读取或写入数据。标准I&#x2F;O函数在默认情况下是行缓冲的，即每次输入或输出都会刷新缓冲区，而系统调用函数则没有缓冲。</p><blockquote><p>缓冲机制：</p><p>行缓存：stdin、stdout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 遇到\n</span><br><span class="line">2. fflush()强制刷新缓存区</span><br><span class="line">3. 文件关闭</span><br><span class="line">4. 程序结束</span><br></pre></td></tr></table></figure><p>无缓存：stderr</p><p>全缓存：通过fopen函数打开的流指针，这个流指针的缓冲区大小是4Kbytes（缓冲区要在文件被使用时才会开辟，只是打开文件并不会开辟缓冲区）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过以下方式刷新全缓存</span><br><span class="line">1. 缓存区满</span><br><span class="line">2. fclose(fp)</span><br><span class="line">3. return </span><br><span class="line">4. exit</span><br><span class="line">5. fflush(fp)</span><br></pre></td></tr></table></figure></blockquote><p>&emsp;&emsp;在使用标准I&#x2F;O函数时，需要注意及时关闭文件以释放资源，以及对错误的处理。此外，还需要注意缓冲区的刷新和文件位置指针的管理，以确保数据的正确读写和定位。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编指令</title>
      <link href="/2023/10/09/ARM/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/10/09/ARM/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我们在进行嵌入式 Linux 开发的时候是绝对要掌握基本的 ARM 汇编，因为 Cortex-A 芯片一上电 SP 指针还没初始化，C 环境还没准备好，所以肯定不能运行 C 代码，必须先用汇编语言设置好 C 环境，比如初始化 DDR、设置 SP指针等等，当汇编把 C 环境设置好了以后才可以运行 C 代码。所以 Cortex-A 一开始肯定是汇编代码，其实 STM32 也一样的，一开始也是汇编，以 STM32F103 为例，启动文件startup_stm32f10x_hd.s 就是汇编文件，只是这个文件 ST 已经写好了，我们根本不用去修改。</p><h2 id="GNU汇编语法"><a href="#GNU汇编语法" class="headerlink" title="GNU汇编语法"></a>GNU汇编语法</h2><p>&emsp;&emsp;ARM汇编语言的基本语法和指令集与其他汇编语言类似，但具体的指令和寄存器名称可能会有所不同，因为它们是针对ARM架构的特定指令集设计的。ARM汇编编译使用的 GCC 交叉编译器，所以我们的汇编代码要符合 GNU 语法。GNU 汇编语法适用于所有的架构，并不是 ARM 独享的，GNU 汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:instruction @ comment</span><br></pre></td></tr></table></figure><ul><li><p><code>label</code>：标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到<br>指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识<br>符都会被识别为一个标号。</p></li><li><p><code>instruction</code>：指令，也就是汇编指令或伪指令。</p></li><li><p><code>@</code>：表示后面的是注释，就跟 C 语言里面的 <code>/*</code> 和 <code>*/</code> 一样，其实在 GNU 汇编文件中我们也可以使用 <code>/*</code> 和 <code>*/</code> 来注释。</p></li><li><p><code>comment</code>：注释内容。</p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add:</span><br><span class="line">MOVS R0, #0X12         @设置 R0=0X12</span><br></pre></td></tr></table></figure><p>上面代码中 <code>add:</code> 就是标号， <code>MOVS R0,#0X12</code> 就是指令，最后的 <code>@设置 R0=0X12</code> 就是注释。</p><p>注意：ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</p><p>用户可以使用 <code>.section</code> 伪操作来定义一个段，每个段以段名开始，以下一段名或者文件结尾结束，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .testsection @定义一个 testsetcion 段</span><br></pre></td></tr></table></figure><p>汇编系统预定义了一些段名：</p><table><thead><tr><th align="center">定义</th><th align="center">段名</th></tr></thead><tbody><tr><td align="center">.text</td><td align="center">表示代码段。</td></tr><tr><td align="center">.data</td><td align="center">初始化的数据段。</td></tr><tr><td align="center">.bss</td><td align="center">未初始化的数据段。</td></tr><tr><td align="center">.rodata</td><td align="center">只读数据段。</td></tr></tbody></table><p>汇编程序的默认入口标号是 <code>_start</code> ，不过我们也可以在链接脚本中使用 <code>ENTRY</code> 来指明其它的入口点，下面的代码就是使用 <code>_start</code> 作为入口标号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">ldr r0, =0x12 @r0=0x12</span><br></pre></td></tr></table></figure><p>上面代码中.global 是伪操作，表示_start 是一个全局标号，类似 C 语言里面的全局变量一样，常见的伪操作有：</p><table><thead><tr><th align="center">伪操作</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">.byte</td><td align="center">定义单字节数据，比如.byte 0x12</td></tr><tr><td align="center">.short</td><td align="center">定义双字节数据，比如.short 0x1234</td></tr><tr><td align="center">.long&#x2F;.word</td><td align="center">定义一个 4 字节数据，比如.long 0x12345678</td></tr><tr><td align="center">.quad</td><td align="center">定义8字节数据</td></tr><tr><td align="center">.float</td><td align="center">定义浮点数</td></tr><tr><td align="center">.string&#x2F;.asciz&#x2F;.ascii</td><td align="center">定义字符串</td></tr><tr><td align="center">.equ</td><td align="center">赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12</td></tr><tr><td align="center">.align</td><td align="center">数据字节对齐，比如：.align 4 表示 4 字节对齐</td></tr><tr><td align="center">.end</td><td align="center">表示源文件结束</td></tr><tr><td align="center">.global</td><td align="center">定义一个全局符号，格式为：.global symbol，比如：.global _start</td></tr></tbody></table><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="搬移指令"><a href="#搬移指令" class="headerlink" title="搬移指令"></a>搬移指令</h3><p>使用处理器做的最多事情就是在处理器内部来回的传递数据，常见的操作有：</p><ul><li>将数据从一个寄存器传递到另外一个寄存器。</li><li>将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。</li><li>将立即数传递到寄存器。</li></ul><ol><li><p>MOV</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@原型: MOV&#123;cond&#125;&#123;S&#125; Rd,Op2</span><br><span class="line"></span><br><span class="line">@详解: 将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面。</span><br><span class="line"></span><br><span class="line">@示例</span><br><span class="line">mov r0,#0x3 @ r0 = 0x3</span><br><span class="line">mov r1,r0@ r1 = r0</span><br></pre></td></tr></table></figure></li><li><p>MRS&#x2F;MSR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@原型: MRS&#123;cond&#125; Rd,psrMSR&#123;cond&#125; psr_fields,#imm8 / MSR&#123;cond&#125; psr_fields,Rm</span><br><span class="line"> </span><br><span class="line">@详解: MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数   据只能使用 MRS 指令。MSR 指令和 MRS 刚好相反，MSR 指令用来将普通寄存器的数据传递给特殊  寄存器，也就是写特殊寄存器，写特殊寄存器只能使用 MSR。</span><br><span class="line"></span><br><span class="line">@示例</span><br><span class="line">mrs r2,cpsr</span><br><span class="line">mov r2,#0xd0</span><br><span class="line">msr cpsr,r2@ svc -&gt; user模式</span><br></pre></td></tr></table></figure></li></ol><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><ol><li><p>AND</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: AND&#123;cond&#125; Rd,Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: Load Rd with logical AND of Rn with Op2.Rd := Rn AND Op2</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">and r5,r0,#0x1 @ r5 = r0 &amp; 0x1</span><br></pre></td></tr></table></figure></li><li><p>ORR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: ORR&#123;cond&#125;&#123;S&#125; Rd,Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: OR operations on the values in Rn and Op2.</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">orr r5,r0,#0xF @ r5 = r0 | 0xF</span><br></pre></td></tr></table></figure></li><li><p>BIC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: BIC&#123;cond&#125;&#123;S&#125; Rd,Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: Perform an AND operation on the bits in Rn with the complements of the corresponding bits in the value of Op2.</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">bic r5,r5,#0x1F @ 会将r5寄存器的低5位清零</span><br></pre></td></tr></table></figure></li><li><p>TST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: TST&#123;cond&#125; Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: Perform a bitwise AND operation on the value of Op2.This is similar to the ANDS instruction,except that the result is discarded.</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">mrs r5,cpsr</span><br><span class="line">tst r5,#0x20@ 测试cpu的状态是ARM还是Thumb 如果为0，cpsr的Z位会自动置1</span><br></pre></td></tr></table></figure></li><li><p>CMP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: CMP&#123;cond&#125; Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: subtracts the value of Op2 from the value in Rn(equals to the SUBS instruction with a discarded result).This instruction updates the condition flags,but do not place a result in a register.</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">cmp r2,r9 @ 从 R2 中减去 R9 的值 ， 如果为0，cpsr的Z位会自动置1</span><br></pre></td></tr></table></figure></li></ol><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><ol><li><p>ADD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: ADD&#123;cond&#125;&#123;S&#125; Rd,Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: Add Rn and Op2 and store result to Rd.</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">add r2,r0,r1 @ r2 = r0+r1,如果使用adds的话会影响cpsr寄存器的符号位N，Z，C，V</span><br></pre></td></tr></table></figure></li><li><p>SUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: SUB&#123;cond&#125;&#123;S&#125; Rd,Rn,Op2</span><br><span class="line"></span><br><span class="line">@ Description: Subtracts the value of Op2 from the value in Rn.</span><br><span class="line"></span><br><span class="line">@ 示例</span><br><span class="line">sub r2,r0,r1 @ r2 = r0-r1,如果使用subs的话会影响cpsr寄存器的符号位N，Z，C，V</span><br></pre></td></tr></table></figure></li><li><p>MUL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><ol><li><p>B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>BL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;如果跳转的地址不在本段而是在其他文件，那么就可能会出现跳转的地址过大（超过了机器码所提供的操作数位数）的问题。为了解决改问题，让地址能够突破32M的限制，使用以下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ldr pc,_swi_hander</span><br><span class="line"></span><br><span class="line">_swi_handler:</span><br><span class="line">.word swi_hander</span><br><span class="line"></span><br><span class="line">swi_hander:</span><br><span class="line">@ xxxx</span><br><span class="line">@ xxxx</span><br></pre></td></tr></table></figure><h3 id="load-store指令"><a href="#load-store指令" class="headerlink" title="load&#x2F;store指令"></a>load&#x2F;store指令</h3><p>&emsp;&emsp;存储器之间是不能直接拷贝数据的，需要借助CPU做中转，例如：flash的数据要拷贝到内存，则需要先将flash的数据load到CPU的寄存器，然后再将寄存器的数据store到内存。</p><ol><li><p>LDR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@ Syntax: LDR&#123;cond&#125; Rd,[Rn]</span><br><span class="line">@  LDR&#123;cond&#125; Rd,[Rn,offset]</span><br><span class="line">@  LDR&#123;cond&#125; Rd,[Rn,offset]!</span><br><span class="line">@  LDR&#123;cond&#125; Rd,label</span><br><span class="line">@  LDR&#123;cond&#125; Rd,[Rn],offset</span><br><span class="line"></span><br><span class="line">@ Description: </span><br><span class="line">@ LDR&#123;cond&#125; Rd,[Rn](zero offset)</span><br><span class="line">@ Rn is used as address value.</span><br><span class="line"></span><br><span class="line">@ LDR&#123;cond&#125; Rd,[Rn,offset](Pre-indexed offset)</span><br><span class="line">@ Rn and offset are added and used as address value.</span><br><span class="line"></span><br><span class="line">@ LDR&#123;cond&#125; Rd,[Rn,offset]&#123;!&#125;(Pre-indexed offset with update)</span><br><span class="line">@ Rn and offset are added and used as address value.The new address value is written to Rn.</span><br><span class="line"></span><br><span class="line">@ LDR&#123;cond&#125; Rd,label(Program-relative)</span><br><span class="line">@ The assembler calculates the PC offset and generates LDR&#123;cond&#125; Rd,[R15,offset].</span><br><span class="line"></span><br><span class="line">@ LDR&#123;cond&#125; Rd,[Rn],offset(Post-indexed offset)</span><br><span class="line">@ Rn is used as address value.After memory transfer,the offset is added to Rn.</span><br></pre></td></tr></table></figure></li><li><p>STR</p><p>str与ldr相反。</p></li></ol><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text@ 代码段</span><br><span class="line"></span><br><span class="line">ldr r0,=src_buf</span><br><span class="line">ldr r1,=dest_buf</span><br><span class="line"></span><br><span class="line">ldr r2,[r0]@ 相当于C语言中的  r2 = *r0</span><br><span class="line">str r2,[r1]@ 相当于C语言中的 *r1 = r2</span><br><span class="line"></span><br><span class="line">src_buf:</span><br><span class="line">.byte 0x1,0x2,0x3,0x4</span><br><span class="line"></span><br><span class="line">.data@ 数据段</span><br><span class="line"></span><br><span class="line">dest_buf:</span><br><span class="line">.space 8    @ 定义8字节的空间</span><br><span class="line"></span><br><span class="line">.end</span><br></pre></td></tr></table></figure><p><strong>批量操作指令</strong></p><p>&emsp;&emsp;LDR&#x2F;STR默认load4个字节的数据（LDRB，load一个字节；LDRH，load两个字节；LDRD,load八个字节），最多也只能load8个字节的数据。如果要批量操作数据，可以使用批量操作指令（ia - Increment Afterib - Increment Beforeda - Dec Afterdb - Dec Before）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldmia r0!, &#123;r3 - r10&#125;@ r0里地址指向的内容批量load到r3~r10寄存器中，r0里地址会自动加4</span><br><span class="line">stmia r0!, &#123;r3 - r10&#125;@ 把r3~r10寄存器中内容，store到r0里地址执行空间中，r0里地址会自动加4</span><br></pre></td></tr></table></figure><p><strong>堆栈操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmfd sp!,&#123;r0-r12,lr&#125;@ 将寄存器r0~r12 lr中的值存入栈中,常用于中断保护现场 !表示会自动偏移</span><br><span class="line">ldmfd sp!,&#123;r0-r12,pc&#125;^@ 将栈中值逐个弹出到寄存器r0~r12 pc中，常用于中断恢复现场,^表示会恢复spsr到cpsr</span><br></pre></td></tr></table></figure><h3 id="高级指令"><a href="#高级指令" class="headerlink" title="高级指令"></a>高级指令</h3><p>软中断指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swi 0x02 @ 产生软中断，软中断号为2</span><br></pre></td></tr></table></figure><img src="/2023/10/09/ARM/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/%E8%BD%AF%E4%B8%AD%E6%96%AD.png" class><p>其中0-23位是软中断号</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.text@ 代码段</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">@ 中断向量b</span><br><span class="line">b reset@ 0x00reset异常的入口</span><br><span class="line">        nop@ldr pc,_undef_handler@ 0x04Undef</span><br><span class="line">ldr pc,_swi_handler@ 0x08swi</span><br><span class="line">nop@ldr pc,_prefetch_handler@ 0x0cprefetch abort</span><br><span class="line">nop@ldr pc,_data_abort_handler@ 0x10Data Abort</span><br><span class="line">nop@ 0x14保留</span><br><span class="line">nop@ldr pc,_irq_handler@ 0x18irq</span><br><span class="line">nop@ldr pc,_fiq_handler@ 0x1cfiq</span><br><span class="line">    _swi_handler:</span><br><span class="line">    .word swi_handler</span><br><span class="line">/*</span><br><span class="line">_undef_handler:</span><br><span class="line">    .word undef_handler</span><br><span class="line"></span><br><span class="line">    _prefetch_handler:</span><br><span class="line">    .word prefetch_handler</span><br><span class="line">    _data_abort_handler:</span><br><span class="line">    .word data_abort_handler</span><br><span class="line">    _irq_handler:</span><br><span class="line">    .word irq_handler</span><br><span class="line">    _fiq_handler:</span><br><span class="line">    .word fiq_handler</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">swi_handler:</span><br><span class="line">ldr sp,=stack_base@ 修改sp的值</span><br><span class="line">stmfd sp!,&#123;r0-r12,lr&#125;@ 现场保护 入栈</span><br><span class="line"></span><br><span class="line">sub r5,lr,#4@ 获取swi指令的地址</span><br><span class="line">ldr r6,[r5]@ 获取机器码</span><br><span class="line">bic r6,#0xff000000 @ r6保存软中断号</span><br><span class="line">cmp r6,#0x02@ open</span><br><span class="line">bleq open</span><br><span class="line"></span><br><span class="line">cmp r6,#0x03@ close</span><br><span class="line">bleq close</span><br><span class="line"></span><br><span class="line">ldmfd sp!,&#123;r0-r12,pc&#125;^  @ 现场恢复 出栈</span><br><span class="line"></span><br><span class="line">open:</span><br><span class="line">mov r2,#0x02</span><br><span class="line">mov pc,lr</span><br><span class="line">close:</span><br><span class="line">mov r2,#0x03</span><br><span class="line">mov pc,lr</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">@ svc-&gt; user模式</span><br><span class="line">mrs r5,cpsr</span><br><span class="line">mov r5,#0xd0</span><br><span class="line">msr cpsr,r5</span><br><span class="line"></span><br><span class="line">mov r0,#3</span><br><span class="line">mov r1,r0</span><br><span class="line"></span><br><span class="line">swi 0x02@ arm core: spsr=cpsr 修改cpsr lr=pc pc=0x08</span><br><span class="line">add r1,r1,#3</span><br><span class="line"></span><br><span class="line">swi 0x03</span><br><span class="line">mov r1,r0</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">buf:</span><br><span class="line">.space 64</span><br><span class="line">stack_base:</span><br><span class="line"></span><br><span class="line">.end</span><br></pre></td></tr></table></figure><h2 id="指令机器码"><a href="#指令机器码" class="headerlink" title="指令机器码"></a>指令机器码</h2><p>&emsp;&emsp;ARM标准模式下的指令集的机器码编码位结构一共有32位，由几个通用部分组成：条件码，识别码，操作标识码，操作数(立即数、地址数等，编码内容看指令的具体含义)。</p><img src="/2023/10/09/ARM/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/20190620170223887.png" class><p>&emsp;&emsp;从图中可以看出，操作数（shifter_operand）的存储大小是固定的（12位）。如果按照常规方式存储，那么操作数的大小最多就只有 2^12^-1 ，那么我们要想使用12位的空间大小存储更大的数，就要使用一些特殊的方法。我们可以将12位空间大小分为4位的循环移位操作数和8位的数据存储。4位循环移位操作数能支持8数据循环移16位，但是这还不够，我们让循环移位操作数的值再乘2为循环移位的实际值，这样就能支持8位数据循环左移32次，这样就能放下实际比 2^12^-1 更大的数。也就是说，只要立即数在循环左移32次以内能够在8位的数据存储空间中放得下，那么这就是一个合法的立即数。可以使用伪指令的方式解决立即数不合法的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ mov r0,#0x12345678 @ 立即数不合法</span><br><span class="line">ldr r0,=0x12345678   @ 伪指令 解决立即数不合法</span><br></pre></td></tr></table></figure><p>数据处理指令</p><img src="/2023/10/09/ARM/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.png" class><p>条件码</p><img src="/2023/10/09/ARM/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E7%A0%81.png" class>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="/2023/10/09/ARM/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/09/ARM/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系结构</title>
      <link href="/2023/10/08/ARM/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/10/08/ARM/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;ARM（Advanced RISC Machine）是一种基于精简指令集计算机（RISC）架构的处理器设计。ARM架构最初由英国公司ARM Holdings开发，现在已成为全球最流行的处理器架构之一。</p><p>ARM架构的主要特点包括：</p><ol><li><p>简化指令集：ARM架构采用了精简指令集，即每条指令的功能都比较简单和基础。这种设计使得指令的执行时间更短，从而提高了处理器的效率和性能。</p></li><li><p>低功耗：ARM架构的处理器设计注重功耗的优化。ARM处理器通常采用低电压和低功耗设计，使其在移动设备和嵌入式系统等电池供电的环境中具有较长的续航时间。</p></li><li><p>可扩展性：ARM架构具有很高的可扩展性，可以用于不同级别的处理器，从低功耗的微控制器到高性能的服务器处理器。这使得ARM架构适用于各种应用领域，包括移动设备、物联网、嵌入式系统、工业控制等。</p></li><li><p>兼容性：ARM架构的指令集在不同的处理器中具有一定的兼容性。这意味着使用ARM架构开发的软件可以在不同的ARM处理器上运行，而不需要进行重新编译或修改。</p></li><li><p>生态系统：ARM架构拥有庞大的生态系统，包括各种芯片制造商、设备制造商、软件开发商和工具提供商。这为开发者提供了广泛的支持和资源，使得开发基于ARM架构的应用更加便捷和高效。</p></li></ol><p>&emsp;&emsp;ARM架构的应用非常广泛，特别是在移动设备领域。目前，大多数智能手机和平板电脑都使用ARM架构的处理器。此外，ARM架构也在物联网、嵌入式系统、工业控制和服务器等领域得到广泛应用。</p><p><strong>ARM处理器最新发展</strong></p><p>cortex-A系列：面向尖端的虚拟内存的操作系统和用户应用。</p><p>cortex-R系列：实时性 通常是用在军工方面。</p><p>cortex-M系列：低功耗、低成本的微控制器方向。</p><p><strong>ARM寄存器组</strong></p><p>ARM 处理器一般共有 37 个寄存器，其中包括：</p><p>（1） 31 个通用寄存器，包括 PC（程序计数器）在内，都是 32 位的寄存器。<br>（2） 6 个状态寄存器，都是 32 位的寄存器。</p><p><strong>ARM处理器7种工作模式</strong></p><ol><li>用户模式（USR）：正常程序执行模式，不能直接切换到其他模式</li><li>系统模式（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权</li><li>快中断模式（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式</li><li>中断模式（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式</li><li>管理模式（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）</li><li>中止模式（ABT）：用于支持虚拟内存和&#x2F;或存储器保护，在ARM7TDMI没有大用处</li><li>未定义模式（UND）：支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式</li></ol><h2 id="ARM异常"><a href="#ARM异常" class="headerlink" title="ARM异常"></a>ARM异常</h2><p>&emsp;&emsp;异常是嵌入式系统能够应对外部突发事件的机制，即马上请求，马上响应。它是理解CPU运转最重要的一个知识点，几乎每种处理器都支持特定异常处理，中断就是异常中的一种。 有时候我们衡量一个操作系统的时候实时性就是看os最短响应中断时间以及单位时间内响应中断次数。</p><p>&emsp;&emsp;在ARM体系结构中，存在7种异常处理。当异常发生时，处理器会把PC设置为一个特定的存储器地址。这一地址放在被称为向量表（vector table）的特定地址范围内，向量表的入口是一些跳转指令，跳转到专门处理某个异常或中断的子程序。</p><ul><li><p>复位异常（Reset）：当CPU刚上电时或按下reset重启键之后进入该异常，我们可以在复位中断服务函数里面做一些初始化工作，比如初始化 SP 指针、 DDR 等等，该异常在管理模式下处理。</p></li><li><p>中断（IRQ&#x2F;FIQ）：由外部硬件触发。CPU和外部设备是分别独立的硬件执行单元，CPU对全部设备进行管理和资源调度处理，CPU要想知道外部设备的运行状态，要么CPU定时的去查看外部设备特定寄存器，要么让外部设备在出现需要CPU干涉处理时“打断”CPU，让它来处理外部设备的请求，毫无疑问第二种方式更合理，可以让CPU”专心”去工作，这里的“打断”操作就叫做中断请求，根据请求的紧急情况，中断请求分一般中断和快速中断，快速中断具有最高中断优先级和最小的中断延迟，通常用于处理高速数据传输及通道的中数据恢复处理，如DMA等，绝大部分外设使用一般中断请求。</p></li><li><p>软中断（Soft interrupt）：该异常是应用程序自己调用时产生的，用于用户程序申请访问硬件资源时，例如：printf()打印函数，要将用户数据打印到显示器上，用户程序要想实现打印必须申请使用显示器，而用户程序又没有外设硬件的使用权，只能通过使用软件中断指令切换到内核态，通过操作系统内核代码来访问外设硬件，内核态是工作在特权模式下，操作系统在特权模式下完成将用户数据打印到显示器上。这样做的目的无非是为了保护操作系统的安全和硬件资源的合理使用，该异常在管理模式下处理。</p></li><li><p>未定义指令异常（Undefined instruction）：该异常发生在流水线技术里的译码阶段，如果当前指令不能被识别为有效指令，产生未定义指令异常，该异常在未定义异常模式下处理。</p></li><li><p>预取指令中止异常（Prefetch abort）：该异常发生在CPU流水线取指阶段，如果目标指令地址是非法地址进入该异常，该异常在中止异常模式下处理。</p></li><li><p>数据异常（Data abort）：该异常发生在要访问数据地址不存在或者为非法地址时，该异常在中止异常模式下处理。</p></li></ul><blockquote><p>异常优先级：Reset &gt; Data abort &gt; FIQ &gt; IRQ &gt; Prefetch abort &gt; Undefined instruction&#x2F;SWI</p></blockquote><h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p><strong>中断控制器(GIC)</strong></p><p>&emsp;&emsp;ARM有两级外部中断 FIQ、IRQ，但大多数基于ARM的系统都不止两个中断源，所以ARM使用中断控制器（通常是地址映射的）来控制中断传递给ARM。</p><p><strong>中断优先级</strong></p><p>ARM还使用了中断优先级来控制中断的执行顺序，并且高优先级的中断还能打断低优先级中断的执行。</p><p><strong>中断标志位</strong></p><p>&emsp;&emsp;当CPU正在处理一个中断时，此时有同优先级中断或低优先级中断触发了，CPU会处理完当前中断再去处理后触发的中断，但是当CPU处理完当前中断后，后触发的中断信号可能已经停止了，所以需要一个中断标志位来保存触发的中断信号。中断处理完后一定要清除中断标志位。</p><p><strong>中断向量表</strong><br>&emsp;&emsp;中断向量是中断服务程序的入口地址，或中断向量表（它是一个中断处理程序地址的数组）的表项。系统程序必须维护一份中断向量表，每一个表项纪录一个中断处理程序的地址。当外部事件或异常产生时，由硬件负责产生一个中断标记，CPU根据中断标记获得相应中断的中断向量号，然后由CPU根据中断向量表的地址和中断向量号去查找中断向量表获得相应中断号的中断程序地址，进一步执行对应的中断处理程序。</p><p>&emsp;&emsp;中断服务程序(函数)在中断向量表中的位置是由半导体厂商定好的，当某个中断被触发以后就会自动跳转到中断向量表中对应的中断服务程序(函数)入口地址处。因此，中断向量表在整个程序的最前面。</p><p>&emsp;&emsp;ARM处理器是从0X00000000开始运行的，理论上中断向量表也应该是存放在0x00000000的，但是实际并不是这样，大部分取决于代码烧录的位置。为了解决这个问题，引入了中断向量表偏移。通过偏移让中断向量表存放在任意地址处。</p><table><thead><tr><th align="center">偏移量</th><th align="center">中断类型</th><th align="center">中断模式</th></tr></thead><tbody><tr><td align="center">0X00</td><td align="center">复位中断(Rest)</td><td align="center">特权模式(SVC)</td></tr><tr><td align="center">0X04</td><td align="center">未定义指令中断(Undefined Instruction)</td><td align="center">未定义指令中止模式(Undef)</td></tr><tr><td align="center">0X08</td><td align="center">软中断(Software Interrupt,SWI)</td><td align="center">特权模式(SVC)</td></tr><tr><td align="center">0X0C</td><td align="center">指令预取中止中断(Prefetch Abort)</td><td align="center">中止模式(Abort)</td></tr><tr><td align="center">0X10</td><td align="center">数据访问中止中断(Data Abort)</td><td align="center">中止模式(Abort)</td></tr><tr><td align="center">0x14</td><td align="center">(Reserved)</td><td align="center"></td></tr><tr><td align="center">0X18</td><td align="center">IRQ 中断(IRQ Interrupt)</td><td align="center">外部中断模式(IRQ)</td></tr><tr><td align="center">0X1C</td><td align="center">FIQ 中断(FIQ Interrupt)</td><td align="center">快速中断模式(FIQ)</td></tr></tbody></table><h2 id="异常处理过程"><a href="#异常处理过程" class="headerlink" title="异常处理过程"></a>异常处理过程</h2><p>当异常产生时，ARM内核会进行如下操作步骤：</p><ol><li>保存执行状态：将CPSR复制到发生的异常模式下<code>SPSR_&lt;mode&gt;</code>中；</li><li>模式切换：<ul><li>CPSR模式位强制设置为与异常类型相对应的值</li><li>处理器进入到ARM执行模式</li><li>设置中断禁止位禁止相应中断（如果需要）</li></ul></li><li>保存返回地址：将下一条指令的地址（被打断程序）保存在LR(异常模式下<code>LR_&lt;mode&gt;</code>)中。</li><li>跳入异常向量表：强制设置PC的值为相应异常向量地址，跳转到异常处理程序中。</li></ol><p>返回时，异常处理需要：</p><ol><li>从<code>SPSR_&lt;mode&gt;</code>恢复CPSR</li><li>从<code>LR_&lt;mode&gt;</code>恢复PC</li><li>这些操作只能在ARM态执行</li></ol><p><strong>每种异常的返回地址</strong></p><table><thead><tr><th align="center">异常类型</th><th align="center">返回地址</th></tr></thead><tbody><tr><td align="center">SWI和Undef</td><td align="center">MOVS pc,lr</td></tr><tr><td align="center">irq、fiq和prefetch</td><td align="center">SUBS pc,lr,#4</td></tr><tr><td align="center">data abort</td><td align="center">SUBS pc,lr,#8</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text@ 代码段</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">@ 中断向量b</span><br><span class="line">b reset@ 0x00reset异常的入口</span><br><span class="line">        ldr pc,_undef_handler@ 0x04Undef</span><br><span class="line">ldr pc,_swi_handler@ 0x08swi</span><br><span class="line">ldr pc,_prefetch_handler@ 0x0cprefetch abort</span><br><span class="line">ldr pc,_data_abort_handler@ 0x10Data Abort</span><br><span class="line">nop@ 0x14保留</span><br><span class="line">ldr pc,_irq_handler@ 0x18irq</span><br><span class="line">ldr pc,_fiq_handler@ 0x1cfiq</span><br><span class="line">_undef_handler:</span><br><span class="line">    .word undef_handler</span><br><span class="line">    _swi_handler:</span><br><span class="line">    .word swi_handler</span><br><span class="line">@ .word是一种汇编指令，用于将一个32位的值存储到指定的位置。在这里，它将swi_handler的地址存储到_swi_handler的位置。</span><br><span class="line">    _prefetch_handler:</span><br><span class="line">    .word prefetch_handler</span><br><span class="line">    _data_abort_handler:</span><br><span class="line">    .word data_abort_handler</span><br><span class="line">    _irq_handler:</span><br><span class="line">    .word irq_handler</span><br><span class="line">    _fiq_handler:</span><br><span class="line">    .word fiq_handler</span><br><span class="line"></span><br><span class="line">swi_handler:</span><br><span class="line">ldr sp,=stack_base@ 修改sp的值</span><br><span class="line">stmfd sp!,&#123;r0-r12,lr&#125;@ 现场保护 入栈</span><br><span class="line">mov r1,#6</span><br><span class="line">ldmfd sp!,&#123;r0-r12,pc&#125;^  @ 现场恢复 出栈</span><br><span class="line">reset:</span><br><span class="line">@ svc-&gt; user模式</span><br><span class="line">mrs r5,cpsr</span><br><span class="line">mov r5,#0xd0</span><br><span class="line">msr cpsr,r5</span><br><span class="line"></span><br><span class="line">mov r0,#3</span><br><span class="line">mov r1,r0</span><br><span class="line">swi 0x02@ arm core: spsr=cpsr 修改cpsr lr=pc pc=0x08</span><br><span class="line">add r1,r1,#3</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">buf:</span><br><span class="line">.space 64</span><br><span class="line">stack_base:</span><br><span class="line"></span><br><span class="line">.end</span><br></pre></td></tr></table></figure><blockquote><p>ldr r0,&#x3D;label是将label这个立即数赋给r0</p><p>ldr r0,label  是将label处的内容赋给r0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存</title>
      <link href="/2023/10/05/ARM/%E5%86%85%E5%AD%98/"/>
      <url>/2023/10/05/ARM/%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;要想理解程序在计算机中是如何由代码变为运行中的进程的，那么内存一定是一个非常重要的概念。在介绍内存之前，我们先简单了解一下计算机的组成部分。</p><p>计算机主要是由硬件和软件两大部分组成：</p><ul><li><p>硬件</p><p>指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。</p><p>主要分为五个部分：控制器、运算器、存储器、输入设备、输出设备</p><p>cpu&#x3D;控制器+运算器</p><p>主板&#x3D;I&#x2F;O总线，输入输出系统</p><p>存储器&#x3D;内存+硬盘</p><p>I&#x2F;O设备：键盘，鼠标，扫描仪，显示器等等</p></li><li><p>软件</p><p>计算机软件(ComputerSoftware)是指计算机系统中的程序及其文档。程序是计算任务的处理对象和处理规则的描述；文档是为了便于了解程序所需的阐述性资料。计算机软件分为系统软件和应用软件，如果把计算机比喻为一个人的话，那么硬件就表示人的身躯。而软件则表示人的思想、灵魂。一台没有安装任何软件的计算机我们把它称之为“裸机”。</p></li></ul><img src="/2023/10/05/ARM/%E5%86%85%E5%AD%98/562c11dfa9ec8a1391e554c5f503918fa0ecc01c.webp" class><p>接下来我们将主要从程序的编写到执行逐步讲解。</p><h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><p>&emsp;&emsp;计算机中程序分为系统程序和应用程序，程序员们编写的一般是应用程序，而应用程序和系统程序有什么区别呢？我们都知道程序是程序员写来让计算机去执行的，而执行程序的一般就是计算机的硬件部分，比如从存储器存取数据，让运算器去运算数据。这就相当于是由程序员去操作计算机的硬件，而实际的开发中，我们程序员并不是直接能操作到硬件的，因为如果能任意操作硬件的话，很可能会带来无法挽回的错误。</p><p>让应用程序直接访问硬件可能会导致以下问题：</p><ol><li>安全性问题：如果应用程序可以直接访问硬件，那么恶意应用程序可能会滥用这种权限，对系统造成损害。例如，恶意应用程序可能会损坏硬件设备、窃取敏感信息或者干扰其他应用程序的正常运行。通过系统程序来管理和限制应用程序对硬件的访问，可以提高系统的安全性。</li><li>稳定性问题：硬件设备通常需要精确的控制和管理，以确保其正常运行。如果应用程序直接访问硬件，可能会导致不稳定性和冲突。例如，多个应用程序同时访问硬件设备可能会引发资源竞争和冲突，导致系统崩溃或者硬件设备无法正常工作。通过系统程序来协调和管理应用程序对硬件的访问，可以提高系统的稳定性。</li><li>抽象和易用性问题：系统程序提供了对硬件的抽象和封装，使得应用程序可以通过统一的接口和API来访问硬件，而不需要关注硬件的具体细节。这种抽象和封装提高了应用程序的易用性和可移植性。如果应用程序直接访问硬件，需要针对不同的硬件设备编写不同的代码，增加了开发和维护的复杂性。</li></ol><p>除了硬件访问的管理和限制，系统程序还负责程序的存储和加载。具体来说，系统程序可以提供以下功能：</p><ol><li>文件系统管理：系统程序负责管理计算机中的文件系统，包括文件的创建、删除、复制、移动等操作。它还负责文件的组织和存储，以便应用程序可以方便地访问和加载文件。</li><li>内存管理：系统程序负责管理计算机的内存资源，包括内存的分配、释放、调度等。当应用程序需要执行时，系统程序会将程序的代码和数据加载到内存中，并为其分配足够的内存空间。在程序执行过程中，系统程序还会监控内存的使用情况，以防止内存泄漏和溢出等问题。</li><li>加载和执行：系统程序负责将程序从存储介质（如硬盘）加载到内存中，并将程序的控制权交给CPU，以便程序可以开始执行。系统程序会解析程序的二进制代码，并将其转换为CPU可以理解的指令。它还负责程序的初始化和资源的分配，以确保程序能够正常运行。</li><li>错误处理：系统程序负责处理程序执行过程中的错误和异常。它会监控程序的运行状态，如运行时间、内存使用情况、IO操作等，并在出现错误或异常时采取相应的措施，如终止程序、回滚操作、发送错误报告等。</li></ol><p>&emsp;&emsp;用系统程序来管理和限制应用程序对硬件的访问，可以提高系统的安全性、稳定性和易用性。系统程序提供了对硬件的抽象和封装，使得应用程序可以通过统一的接口来访问硬件，而不需要直接与硬件交互。这种分层架构有助于保护系统和应用程序的正常运行。</p><p>另外：有些计算机是可以不需要系统程序的，在这种计算机上能直接操控硬件，也就是裸机开发。常见的就是MCU（Microcontroller Unit），也就是俗称的单片机。</p><blockquote><p>因此，嵌入式软件开发就分为了应用层开发和驱动开发。应用层开发只需要获取底层提供的接口，而不需要了解底层如何实现。驱动开发则是更关注于系统软件，为上层应用提供接口，以及操作硬件。</p></blockquote><h2 id="程序的存储"><a href="#程序的存储" class="headerlink" title="程序的存储"></a>程序的存储</h2><p>程序从编写到存储的过程可以简单概括为以下几个步骤：</p><ol><li><p>编写源代码：程序员使用编程语言编写程序的源代码。源代码是以可读的文本形式表示的程序代码，它包含了程序的逻辑、算法和功能实现。</p></li><li><p>编译或解释：源代码需要经过编译或解释过程，将其转换为计算机可以执行的形式。</p></li></ol><ul><li><p>编译：编译器将源代码作为输入，将其转换为机器语言或字节码等与特定硬件或操作系统相关的形式。编译过程将源代码转换为可执行文件，其中包含了程序的机器指令和数据。</p></li><li><p>解释：解释器逐行解释源代码，并在运行时执行相应的操作。解释过程不会生成可执行文件，而是直接在运行时执行源代码。</p></li></ul><ol start="3"><li>存储程序文件：生成的可执行文件或源代码文件需要存储在计算机的存储介质中，以便在需要时进行加载和执行。</li></ol><ul><li><p>可执行文件：编译后的程序通常会生成可执行文件，该文件包含了程序的机器指令和数据。可执行文件可以直接在操作系统中运行。</p></li><li><p>源代码文件：源代码文件以可读的文本形式保存程序的源代码。源代码文件通常以特定的文件扩展名（如.py、.java、.c）保存，以便在需要时进行编辑和编译。</p></li></ul><p>&emsp;&emsp;程序员写的程序一般存在于开发环境或文本编辑器中。开发环境（如IDE）提供了编写、调试和管理程序的功能。程序员可以在开发环境中创建和编辑源代码文件，并进行编译、调试和运行等操作。程序员也可以使用文本编辑器（如记事本、Sublime Text、VS Code等）来编写源代码文件，并使用命令行工具或集成开发环境来进行编译和执行。</p><p>&emsp;&emsp;在开发过程中，程序员通常会使用版本控制系统（如Git）来管理和追踪程序的变化。通过版本控制系统，程序员可以保存和管理不同版本的程序，以便在需要时进行回滚、合并和协作等操作。版本控制系统也提供了远程存储库的功能，可以将程序存储在云端，方便团队协作和备份。</p><h2 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h2><p><strong>程序和进程</strong></p><p>&emsp;&emsp;程序是一个静态的概念，通常我们编译源代码生成的可执行程序是存储于硬盘中的，当我们执行这个程序时，它会被操作系统给load到内存里面，此时运行中的程序就称为进程。</p><p>当要运行一个可执行程序时，计算机会经历以下步骤：</p><ol><li><p>加载程序：操作系统会从存储介质（如硬盘）中读取可执行文件，并将其加载到内存中。加载过程包括将程序的指令和数据复制到内存中的适当位置，并进行必要的初始化和资源分配。</p></li><li><p>解析指令：CPU会逐条解析内存中的指令，并执行相应的操作。指令包括了程序的逻辑和功能，如算术运算、条件判断、循环等。</p></li><li><p>执行程序：CPU按照指令的顺序执行程序的逻辑。这包括了对数据的处理、操作系统的调用、与其他程序的交互等。程序的执行过程可能涉及到多个线程或进程的并发执行，以提高计算机的效率和响应性。</p></li><li><p>输出结果：程序的执行结果可以通过多种方式输出，如在屏幕上显示、写入文件、发送网络数据等。程序可以使用操作系统提供的API或库来进行输出操作。</p></li><li><p>释放资源：当程序执行完毕或被终止时，操作系统会释放程序所占用的内存和其他资源，以便其他程序可以使用。</p></li></ol><p>&emsp;&emsp;运行可执行程序的过程通常由操作系统负责管理。操作系统提供了运行程序的环境和接口，以便程序可以与计算机的硬件和其他软件进行交互。操作系统还负责调度和管理程序的执行，以确保计算机的资源被合理分配和利用。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>man手册</title>
      <link href="/2023/09/29/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/man%E6%89%8B%E5%86%8C/"/>
      <url>/2023/09/29/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/man%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;man手册是Unix和类Unix操作系统上的命令行工具的手册页（manual page）。这些手册页提供了关于特定命令、函数和系统调用的详细信息。man手册分为9个节（section），每个节都有特定的内容，使用man的时候可以指定不同的section来实现查找。</p><ol><li>用户命令：包含常用的用户命令，如ls、cp、mv等。</li><li>系统调用：包含系统级函数和系统调用接口，如open、read、write等。</li><li>库函数：包含C语言库函数的说明，如printf、malloc等。</li><li>特殊文件：包含特殊文件的说明，如&#x2F;dev下的设备文件、设备驱动等。</li><li>文件格式：包含文件格式和配置文件的说明，如&#x2F;etc&#x2F;passwd、fstab等。</li><li>游戏和屏幕保护程序：包含游戏和屏幕保护程序的说明，游戏预留，由游戏自己定义。</li><li>杂项：标准文件系统布局、手册页结构等杂项内容，还包含其他的一些说明，如宏包、协议等。</li><li>系统管理员命令：包含系统管理员使用的命令，这些命令只能由root使用，如mount、reboot等。</li><li>内核例程：包含内核例程和内核模块的说明，非标准手册小节，用于Linux内核开发。</li></ol><p>&emsp;&emsp;你可以使用man命令加上相应的节号来查看特定命令或函数的手册页。例如，”man 1 ls”可以查看ls命令的手册页，”man 2 open”可以查看open系统调用的手册页。如果不加数字，man手册会按照它本身的section的顺序寻找。</p><p>示例：<code>$ man chmod</code></p><img src="/2023/09/29/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/man%E6%89%8B%E5%86%8C/ZD8Y@MXX)MOG%5D2E~0)NHW9E.png" class><p>分析：</p><ul><li>CHMOD(1) 这里的1就是section编号</li><li>NAME 是这个命令的名字</li><li>SYNOPSIS 是简要描述命令的语法，中括号括起来的参数是可选参数，参数后的省略号表示这个参数可以重复使用多次</li><li>DESCRIPTION 详细说明这个命令的用法</li><li>AUTHOR 命令的作者</li></ul><p>注意：许多命令和函数的名字是重复的，所以当我们使用man的时候，最好加上手册的section号。</p><p>&emsp;&emsp;man手册提供了命令的语法、选项、参数以及示例等详细信息，可以帮助用户了解和正确使用系统中的各种命令和函数。通过man手册，用户可以快速查找和学习系统的功能和用法，提高操作和开发的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"/>
      <url>/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/</url>
      
        <content type="html"><![CDATA[<p>​Git是目前最流行的分布式版本控制系统之一。它被广泛用于管理软件和其他文本文件的版本控制，并协助多人协同开发。Git由Linux操作系统的内核创始人Linus Torvalds在2005年创造，以处理其自己的内部版本管理需求。自那时起，Git已经成为一个重要的工具，被许多公司和开源项目用来维护代码库、跟踪更改并记录历史。</p><h2 id="1-初始化配置"><a href="#1-初始化配置" class="headerlink" title="1. 初始化配置"></a>1. 初始化配置</h2><p>使用 git config 命令配置用户名和邮箱，只用执行一次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置用户名,有空格需要加上双引号</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Huang Xiaoyu&quot;</span></span><br><span class="line"><span class="comment">#--Local 参数(省略) : 本地配置，只对本地仓库有效。</span></span><br><span class="line"><span class="comment">#--global 参数 : 全局配置。所有仓库生效。</span></span><br><span class="line"><span class="comment">#--system 参数 : 系统配置，对所有用户生效。</span></span><br><span class="line"><span class="comment">#配置邮箱,没有空格不用加上双引号</span></span><br><span class="line">git config --global user.email 1442340493@qq.com</span><br><span class="line"><span class="comment">#保存用户名和密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"><span class="comment">#查看配置信息</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h2 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2. 新建仓库"></a>2. 新建仓库</h2><p><strong>方式一：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先创建一个空目录</span></span><br><span class="line"><span class="built_in">mkdir</span> learn-git</span><br><span class="line"><span class="built_in">cd</span> learn-git</span><br><span class="line"><span class="comment">#创建仓库，会生成一个.git的隐藏目录，使用ls -a可以查看，里面的东西不可随意更改，否则会破坏仓库，git init 后面还可以直接加上仓库的名称，这样也会新建一个目录作为git仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在远程服务器(Github  Gitee...)上克隆已经存在的仓库</span></span><br><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure><h2 id="3-工作区域和文件状态"><a href="#3-工作区域和文件状态" class="headerlink" title="3. 工作区域和文件状态"></a>3. 工作区域和文件状态</h2><p>git的本地数据管理分为三个区域：</p><ol><li>工作区（Working Directory）：实际操作的目录。</li><li>暂存区（Staging Area&#x2F;Index）：中间区域，用于临时存放即将提交的修改内容。</li><li>本地仓库（Local Repository）：Git存储代码和版本信息的主要位置。</li></ol><p> git的文件存在四种状态：</p><ol><li>未跟踪（Untrack）：新创建的还未被Git管理起来的文件。</li><li>未修改（Unmodified）：已经被Git管理起来但文件的内容没有发生变化的文件。</li><li>已修改（Modified）：已经修改但还没有添加到暂存区的文件。</li><li>已暂存（Staged）：已经修改也已经添加到暂存区的文件。</li></ol><h2 id="4-添加和提交文件"><a href="#4-添加和提交文件" class="headerlink" title="4. 添加和提交文件"></a>4. 添加和提交文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment">#查看仓库的状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#添加到暂存区</span></span><br><span class="line">git add</span><br><span class="line"><span class="comment">#添加所有文件</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">#查看暂存区内容</span></span><br><span class="line">git ls-files</span><br><span class="line"><span class="comment">#提交</span></span><br><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br><span class="line"><span class="comment"># -a 参数设置修改文件后不需要执行 git add 命令，直接提交</span></span><br><span class="line">git commit -am ”提交信息“</span><br><span class="line"><span class="comment">#查看提交记录 加上 --oneline 参数显示简略信息</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="5-回退版本"><a href="#5-回退版本" class="headerlink" title="5. 回退版本"></a>5. 回退版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br><span class="line"><span class="comment"># --soft 参数:回退到某一个版本，并且保留工作区和暂存区的所有修改内容</span></span><br><span class="line"><span class="comment"># --hard 参数:回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容</span></span><br><span class="line"><span class="comment"># --mixed 默认参数:回退到某一个版本，并且只保留工作区的修改内容而丢弃暂存区的修改内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看历史操作记录</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment">#回退某一操作之前的版本，比如误将工作区、暂存区内容清空。</span></span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><h2 id="6-查看差异"><a href="#6-查看差异" class="headerlink" title="6. 查看差异"></a>6. 查看差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件在工作区、暂存区之间的差异,加上文件名就可以只查看这个文件的差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment">#比较工作区和版本库之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">#比较暂存区和版本库之间的差异</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件在两个特定版本之间的差异，使用HEAD可以表示当前分支的最新提交节点</span></span><br><span class="line">git diff 版本号1 版本号2</span><br><span class="line"><span class="comment">#比较当前版本和上一个版本之间的差异(HEAD~表示HEAD上一个版本，HEAD~2表示HEAD之前两个版本)</span></span><br><span class="line">git diff HEAD~ HEAD</span><br><span class="line">git diff HEAD^ HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件在两个分支之间的差异</span></span><br></pre></td></tr></table></figure><h2 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7. 删除文件"></a>7. 删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 删除工作区和暂存区后直接提交</span></span><br><span class="line"><span class="built_in">rm</span> file3.txt</span><br><span class="line">git add file3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 使用 git rm 后直接提交</span></span><br><span class="line">git <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 删除版本库中的文件</span></span><br><span class="line">git <span class="built_in">rm</span> --cached</span><br></pre></td></tr></table></figure><h2 id="8-忽略文件"><a href="#8-忽略文件" class="headerlink" title="8. 忽略文件"></a>8. 忽略文件</h2><p>应该忽略以下文件：</p><ul><li>系统或者软件自动生成的文件</li><li>编译产生的中间文件和结果文件</li><li>运行时生成日志文件、缓存文件、临时文件</li><li>涉及身份、密码、口令、密钥等敏感信息文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;日志文件&quot;</span> &gt; access.log</span><br><span class="line"><span class="built_in">echo</span> access.log &gt; .gitignore</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 .gitignore文件中加上 *.log 会忽略所有.log结尾的文件。</span></span><br><span class="line"><span class="comment">#在 .gitignore文件中加上 文件夹名称 会忽略文件夹中所有文件。</span></span><br><span class="line"><span class="comment">#已经添加到版本库中的文件不会被忽略。</span></span><br></pre></td></tr></table></figure><p><strong>.gitignore文件的匹配规则</strong></p><p>从上到下逐行匹配，每一行表示一个忽略模式</p><ul><li>空行或者以#开头的行会被Git忽略。一般空行用于可读性的分隔，#一般用作注释</li><li>使用标准的Blob模式匹配，例如：<ul><li>*通配任意个字符</li><li>?匹配单个字符</li><li>[]表示匹配列表中的单个字符，比如：[abc] 表示 a&#x2F;b&#x2F;c</li></ul></li><li>两个 ** 表示匹配任意的中间目录</li><li>中括号可以使用短中线连接，比如：[0-9]</li><li>!表示取反，忽略指令模式以外的文件或目录</li></ul><h2 id="9-SSH配置和克隆仓库"><a href="#9-SSH配置和克隆仓库" class="headerlink" title="9. SSH配置和克隆仓库"></a>9. SSH配置和克隆仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment">#生成SSH Key，私钥文件 : id_rsa 公钥文件 : id_rsa.pub</span></span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line"><span class="comment">#克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> repo-address</span><br><span class="line"><span class="comment">#推送更新内容</span></span><br><span class="line">git push &lt;remote&gt;&lt;branch&gt;</span><br><span class="line"><span class="comment">#拉取更新内容</span></span><br><span class="line">git pull &lt;remote&gt;</span><br></pre></td></tr></table></figure><h2 id="10-关联本地仓库和远程仓库"><a href="#10-关联本地仓库和远程仓库" class="headerlink" title="10. 关联本地仓库和远程仓库"></a>10. 关联本地仓库和远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加远程仓库:</span></span><br><span class="line">git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;<span class="comment">#step1</span></span><br><span class="line">git push -u &lt;远程仓库名&gt; &lt;分支名&gt;<span class="comment">#step2</span></span><br><span class="line"><span class="comment">#查看远程仓库:</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment">#拉取远程仓库内容:</span></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="11-Gitee的使用和GitLab本地化部署"><a href="#11-Gitee的使用和GitLab本地化部署" class="headerlink" title="11. Gitee的使用和GitLab本地化部署"></a>11. Gitee的使用和GitLab本地化部署</h2><p>Gitee：国内平台</p><p>GitLab：私有化部署</p><h2 id="12-分支简介和基本操作"><a href="#12-分支简介和基本操作" class="headerlink" title="12. 分支简介和基本操作"></a>12. 分支简介和基本操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看分支列表</span></span><br><span class="line">git b</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建新分支</span></span><br><span class="line">git branch &lt;新分支名&gt;</span><br><span class="line"><span class="comment">#切换分支 git checkout 也可以切换分支，但有歧义(恢复文件)</span></span><br><span class="line">git switch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并分支，将目标分支合并到当前分支</span></span><br><span class="line">git merge &lt;要合并的分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看分支图</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除已经完成合并的分支</span></span><br><span class="line">git branch -d &lt;分支名&gt;</span><br><span class="line"><span class="comment">#强制删除没有进行合并的分支</span></span><br><span class="line">git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode</title>
      <link href="/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VScode/"/>
      <url>/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VScode/</url>
      
        <content type="html"><![CDATA[<h2 id="VScode简介"><a href="#VScode简介" class="headerlink" title="VScode简介"></a>VScode简介</h2><p>Visual Studio Code（简称VS Code）是一个轻量级的源代码编辑器，由Microsoft开发。它支持多种编程语言和文件类型，并提供了丰富的功能和扩展性。</p><p>VS Code具有以下特点：</p><ol><li><p>跨平台支持：VS Code可在Windows、macOS和Linux等多个操作系统上运行，使开发者能够在不同的平台上保持一致的开发体验。</p></li><li><p>丰富的功能：VS Code提供了强大的编辑功能，包括语法高亮、智能代码补全、代码导航、代码片段、代码折叠、多光标编辑等。它还支持Git集成、调试器、终端、任务运行器等功能，使开发者能够在一个编辑器中完成大部分开发任务。</p></li><li><p>扩展性：VS Code支持丰富的扩展，开发者可以根据自己的需求选择和安装各种插件。这些插件可以提供额外的语言支持、工具集成、主题和界面定制等功能，使编辑器更加适应个人偏好和项目需求。</p></li><li><p>内置的集成终端：VS Code内置了终端，可以直接在编辑器中执行命令和运行脚本，无需切换到外部终端。</p></li><li><p>强大的调试功能：VS Code提供了调试器的支持，可以方便地进行代码调试和错误排查。它支持多种编程语言的调试，包括JavaScript、Python、C++等。</p></li></ol><p>总的来说，VS Code是一个功能强大、轻量级且可扩展的源代码编辑器。它提供了丰富的功能和插件，使开发者能够在一个编辑器中完成大部分开发任务。无论是进行日常的代码编辑、调试还是进行项目开发，VS Code都是一个非常受欢迎的选择。</p><h2 id="VScode连接Linux虚拟机"><a href="#VScode连接Linux虚拟机" class="headerlink" title="VScode连接Linux虚拟机"></a>VScode连接Linux虚拟机</h2><p>​使用VS Code连接Linux虚拟机进行开发的好处是，你可以在本地的编辑器中进行代码编写、调试和测试，无需在虚拟机中切换窗口或使用其他编辑器。这样可以提高开发效率，减少不必要的操作。同时，VS Code提供了丰富的编辑功能和扩展生态系统，可以帮助你更快地编写代码，减少出错的可能性。此外，VS Code还内置了终端支持和调试器，方便执行命令、运行脚本和进行代码调试。</p><p><strong>操作步骤</strong></p><p>使用VS Code连接Linux虚拟机可以按照以下步骤进行：</p><ul><li><p>配置虚拟机</p><ol><li><p>确保虚拟机的ssh服务可用</p><p>打开虚拟机，在终端命令行上敲入：sudo apt-get install openssh-server进行安装。</p><p>终端输入<code>systemctl status sshd</code>如果出现以下信息则表明虚拟机的ssh服务是打开的</p><img src="/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VScode/image-20230929214506470.png" class></li><li><p>使用<code>ifconfig</code>命令查看虚拟机IP地址</p></li></ol></li><li><p>配置VScode</p><ol><li>安装VS Code：从<a href="https://code.visualstudio.com/">VS Code官方网站</a>下载适用于你操作系统的安装包，并按照安装向导进行安装。</li><li>安装Remote Development扩展：打开VS Code编辑器后，在扩展商店中搜索并安装”Remote Development”扩展。这个扩展提供了连接远程服务器的功能。</li><li>配置SSH连接：在VS Code的侧边栏中点击扩展按钮（四个方块图标），找到”Remote-SSH”扩展。点击”Remote-SSH”扩展，选择”Connect to Host”，然后选择”Add New SSH Hosts…”（第一次成功后，之后再想连接直接选择虚拟机对应的IP地址就好了）。在弹出的输入框中按提示输入<code>ssh 用户名@虚拟机IP地址</code>（IP地址可以用虚拟机主机名代替）。输入完毕之后，点击确认下一步，选择保存SSH配置文件的路径，这里默认选择第一个就好。</li></ol></li></ul><p>通过以上步骤，你就可以使用VS Code连接Linux虚拟机进行开发了。</p><h2 id="VScode上传文件到Git"><a href="#VScode上传文件到Git" class="headerlink" title="VScode上传文件到Git"></a>VScode上传文件到Git</h2><p>VScode自带有支持Git的插件，用VScode打开一个Git仓库。之后点击Git图标，在这里就可以执行提交修改到暂存区、将暂存区文件上传本地仓库以及推送文件到Github等操作。</p><img src="/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VScode/image-20230929220753200.png" class><p>大部分git命令能完成的操作也都可以直接在这里执行。</p><img src="/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VScode/image-20230929220918200.png" class><p>更加详细的操作请读者查阅相关资料。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本</title>
      <link href="/2023/09/28/Linux/Shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/09/28/Linux/Shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p> Shell的作用是解释执行用户的命令，用户输入一条命令，Shell就解释执行一条，这种方式称为交互式（Interactive），Shell还有一种执行命令的方式称为批处理（Batch），用户事先写一个Shell脚本（Script），其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。Shell脚本是在Unix、Linux和类Unix系统中使用的一种脚本语言，用于编写一系列的命令和操作，以便在命令行中执行，消除重复的工作，其本质就是一系列shell命令的集合。Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，它为用户提供了一个面向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。<br>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。它可以执行一系列的命令、控制结构、变量和函数，以实现特定的任务，适用于系统管理、文件处理、数据处理、自动化测试等各种场景。</p><img src="/2023/09/28/Linux/Shell%E8%84%9A%E6%9C%AC/v2-497551e46d2b987313ddc456fb3a8f30_r.jpg" class><blockquote><p>Shell具体可描述为：外层应用程序是一些命令，是非机器语言，比如ls ， useradd等；而内核则识别的是机器语言0和1，让Shell解释器当一个“中介”，由非机器语言通过Shell解释器向机器语言的转化，转化后内核将命令传递给硬件执行。更直白的说，Shell就是我们操控的Linux终端界面，输入命令得到想要的功能。</p></blockquote><h2 id="Shell环境"><a href="#Shell环境" class="headerlink" title="Shell环境"></a>Shell环境</h2><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li><li>Bourne Again Shell（&#x2F;bin&#x2F;bash）</li><li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li><li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li><li>Shell for Root（&#x2F;sbin&#x2F;sh）</li><li>……</li></ul><p>我们主要关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><p><code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h2 id="创建和执行Shell脚本"><a href="#创建和执行Shell脚本" class="headerlink" title="创建和执行Shell脚本"></a>创建和执行Shell脚本</h2><p>创建一个.sh脚本文件，扩展名sh代表shell，扩展名并不影响程序运行，但最好见名知义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello word&quot;</span></span><br></pre></td></tr></table></figure><p><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>shell脚本的执行有两种方式：</p><ul><li><p>第一种方式：用bash解释器执行脚本文件，<code>bash 脚本文件名</code>，这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash test.sh</span><br><span class="line">/bin/sh test.sh</span><br><span class="line">bash test.sh</span><br><span class="line">sh test.sh</span><br></pre></td></tr></table></figure></li><li><p>第二种方式：用chmod给脚本文件添加可执行权限，使其变为可执行程序，再执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>解释器和编译器的区别：</p><p>解释器是一条一条的解释执行源语言。比如php，postscritp，javascript就是典型的解释性语言。它的优点是容易跨平台，同一套代码可以在几乎所有的操作系统上执行，而无需根据操作系统做修改；</p><p>编译器是把源代码整个编译成目标代码，它生成目标代码再由连接器生成可执行的机器码，执行时不再需要编译器，直接在支持目标代码的平台上运行，这样执行效率比解释执行快很多。缺点是需要根据不同的操作系统编制代码，虽然有像Qt这样的源代码级跨平台的编程工具库，但在不同的平台上仍然需要重新编译连接成可执行文件，但其执行效率要远远高于解释运行的程序。比如C语言代码被编译成二进制代码（exe程序），在windows平台上执行。</p></blockquote><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p><strong>变量的类型</strong></p><ul><li><p>自定义变量</p><ul><li>用户自己定义的变量</li><li>变量没有数据类型，默认为字符串类型</li><li>初始化的时候&#x3D;两边都不要留空</li><li>变量的调用需要加<code>$</code></li><li>当变量和其它字符串一起的时候，调用加<code>&#123;&#125;</code></li><li>不能直接变量&#x3D;变量，需要在右边的变量加<code>$</code></li><li>没有分号，以换行作为一个语句的结束</li></ul></li><li><p>位置变量</p><p>计算机把命令行参数的值传递给特定的变量从0开始调用，10以上的用{}括起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$&#123;10&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>预定义变量</p><p>计算机已经给一些特定的字符赋予了特殊的意义</p><p><code>$*</code>:所有的位置变量，但是不包括<code>$0</code><br><code>$@</code>:所有的位置变量，但是不包括<code>$0</code><br><code>$#</code>:位置变量的个数，但是不包括<code>$0</code><br><code>$?</code>:获得之前(上一个)进程(shell命令)结束的状态码 (0 表示成功, 1 表示失败)<br><code>$$</code>:获得当前进程 ID<br><code>$!</code>:获得之前(上一个)进程 ID</p></li><li><p>环境变量</p><ul><li>计算机已经赋值好的变量</li><li>env查看所有的环境变量</li><li>调用环境变量也需要加$</li></ul></li></ul><p>只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myName=<span class="string">&quot;HXY&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myName</span><br></pre></td></tr></table></figure><p>删除变量：使用 unset 命令可以删除变量（不能删除只读变量）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure><p><strong>变量运算</strong></p><ul><li><p><code>$(())</code></p><ul><li>能进行+-*&#x2F;%运算</li><li>能进行自加自减</li><li>能进行幂数运算</li><li>不能进行浮点型运算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=2</span><br><span class="line">b=3</span><br><span class="line">c=$((a**b))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$c</span></span><br></pre></td></tr></table></figure><blockquote><p>上面这个脚本使用<code>sh</code>解释器执行会报错，原因是<code>**</code>是 <code>bash</code> 运算符，在 <code>sh</code>里还没声明，所以报错。</p><p>注：<code>Debian</code>和<code>Ubuntu</code> 默认用<code>sh</code>作为<code>/bin/sh</code>的解释器</p></blockquote></li><li><p><code>$[]</code></p><ul><li>能进行+-*&#x2F;%运算</li><li>能进行自加自减</li><li>能进行幂数运算</li><li>不能进行浮点型运算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">b=34</span><br><span class="line">a=$[2**4]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure></li><li><p>expr</p><ul><li>需要用命令置换符&#96;&#96;置换出来结果</li><li>能进行<code>+-*/%</code>，但是在进行乘法运算的时候需要加<code>\*</code>和通配符<code>*</code>区分</li><li>不能进行幂数运算</li><li>不能进行浮点型运算</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">b=34</span><br><span class="line">a=`<span class="built_in">expr</span> 1 + 3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p><strong>shell字符串</strong></p><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号（有空格时一定要用引号）。</p><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。如果要在单引号里使用变量，需要将变量再用一对单引号包括起来。</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">&quot;HXY&quot;</span></span><br><span class="line">str=<span class="string">&#x27;My name is &#x27;</span><span class="variable">$my_name</span><span class="string">&#x27;!&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="variable">$str</span></span><br></pre></td></tr></table></figure><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li><li>双引号里可以直接使用单引号，不用转义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">&quot;HXY&quot;</span></span><br><span class="line">str=<span class="string">&quot;This&#x27;s my name <span class="variable">$my_name</span>!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="variable">$str</span></span><br></pre></td></tr></table></figure><p><strong>获取字符串长度</strong></p><p>实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span>    <span class="comment"># 输出 4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string[0]&#125;</span> <span class="comment"># 输出 4</span></span><br><span class="line"><span class="comment"># 变量为字符串时，$&#123;#string&#125; 等价于 $&#123;#string[0]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>提取子字符串</strong></p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;hxy is a cool boy&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:0:3&#125;</span> <span class="comment"># 从第0个元素开始提取3个字符</span></span><br></pre></td></tr></table></figure><p><strong>查找子字符串</strong></p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字符 m 或 n 的位置(哪个字母先出现就计算哪个)</span></span><br><span class="line">string=<span class="string">&quot;my name is hxy&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">expr</span> index <span class="string">&quot;<span class="variable">$string</span>&quot;</span> mn`<span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure><p>注意：这里输出的位置不是从0开始，而是从1开始。</p><h2 id="shell语句"><a href="#shell语句" class="headerlink" title="shell语句"></a>shell语句</h2><p><strong>解释性语句</strong></p><ul><li><p>注释一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br></pre></td></tr></table></figure></li><li><p>注释多行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上例子中，: 是一个空命令，用于执行后面的 Here 文档，&lt;&lt;&#x27;EOF&#x27; 表示开启 Here 文档，EOF 是 Here 文档的标识符，在这两个标识符之间的内容都会被视为注释，不会被执行。这个标识符可以随便取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line">: <span class="string">&#x27;</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="comment"># 我们也可以使用了冒号 : 命令，并用单引号 &#x27; 将多行内容括起来。由于冒号是一个空命令，这些内容不会被执行。冒号和单引号之间要用空格隔开</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>功能性语句</strong></p><ul><li><p>read</p><p>read命令用于从标准输入中读取输入单行，并将读取的单行根据IFS变量分裂成多个字段，并将分割后的字段分别赋值给指定的变量列表var_name。第一个字段分配给第一个变量var_name1，第二个字段分配给第二个变量var_name2，依次到结束。如果指定的变量名少于字段数量，则多出的字段数量也同样分配给最后一个var_name，如果指定的变量命令多于字段数量，则多出的变量赋值为空。如果没有指定任何var_name，则分割后的所有字段都存储在特定变量REPLY中。</p><p>选项说明：</p><ul><li>-a：将分裂后的字段依次存储到指定的数组中，存储的起始位置从数组的index&#x3D;0开始。</li><li>-d：指定读取行的结束符号。默认结束符号为换行符。</li><li>-n：限制读取N个字符就自动结束读取，如果没有读满N个字符就按下回车或遇到换行符，则也会结束读取。</li><li>-N：严格要求读满N个字符才自动结束读取，即使中途按下了回车或遇到了换行符也不结束。其中换行符或回车算一个字符。</li><li>-p：给出提示符。默认不支持”\n”换行，要换行需要特殊处理，见下文示例。例如，”-p 请输入密码：”</li><li>-r：禁止反斜线的转义功能。这意味着”&quot;会变成文本的一部分。</li><li>-s：静默模式。输入的内容不会回显在屏幕上。</li><li>-t：给出超时时间，在达到超时时间时，read退出并返回错误。也就是说不会读取任何内容，即使已经输入了一部分。</li><li>-u：从给定文件描述符(fd&#x3D;N)中读取数据。</li></ul></li><li><p>test</p><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><ul><li><p>数值测试</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">等于则为真</td></tr><tr><td align="center">-ne</td><td align="center">不等于则为真</td></tr><tr><td align="center">-gt</td><td align="center">大于则为真</td></tr><tr><td align="center">-ge</td><td align="center">大于等于则为真</td></tr><tr><td align="center">-lt</td><td align="center">小于则为真</td></tr><tr><td align="center">-le</td><td align="center">小于等于则为真</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数相等！&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数不相等！&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>字符串测试</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">等于则为真</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不相等则为真</td></tr><tr><td align="center">-z</td><td align="center">字符串的长度为零则为真</td></tr><tr><td align="center">-n</td><td align="center">字符串的长度不为零则为真</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="string">&quot;ru1noob&quot;</span></span><br><span class="line">num2=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$num1</span> = <span class="variable">$num2</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个字符串相等!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个字符串不相等!&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>文件测试</p><p>文件类型判断</p><table><thead><tr><th align="center">选 项</th><th align="center">作 用</th></tr></thead><tbody><tr><td align="center">-b filename</td><td align="center">判断文件是否存在，并且是否为块设备文件。</td></tr><tr><td align="center">-c filename</td><td align="center">判断文件是否存在，并且是否为字符设备文件。</td></tr><tr><td align="center">-d filename</td><td align="center">判断文件是否存在，并且是否为目录文件。</td></tr><tr><td align="center">-e filename</td><td align="center">判断文件是否存在。</td></tr><tr><td align="center">-f filename</td><td align="center">判断文件是否存在，井且是否为普通文件。</td></tr><tr><td align="center">-L filename</td><td align="center">判断文件是否存在，并且是否为符号链接文件。</td></tr><tr><td align="center">-p filename</td><td align="center">判断文件是否存在，并且是否为管道文件。</td></tr><tr><td align="center">-s filename</td><td align="center">判断文件是否存在，并且是否为非空。</td></tr><tr><td align="center">-S filename</td><td align="center">判断该文件是否存在，并且是否为套接字文件。</td></tr></tbody></table><p>文件权限判断</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">-r filename</td><td align="center">判断文件是否存在，并且是否拥有读权限。</td></tr><tr><td align="center">-w filename</td><td align="center">判断文件是否存在，并且是否拥有写权限。</td></tr><tr><td align="center">-x filename</td><td align="center">判断文件是否存在，并且是否拥有执行权限。</td></tr><tr><td align="center">-u filename</td><td align="center">判断文件是否存在，并且是否拥有 SUID 权限。</td></tr><tr><td align="center">-g filename</td><td align="center">判断文件是否存在，并且是否拥有 SGID 权限。</td></tr><tr><td align="center">-k filename</td><td align="center">判断该文件是否存在，并且是否拥有 SBIT 权限。</td></tr></tbody></table><p>文件比较</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">filename1 -nt filename2</td><td align="center">判断 filename1 的修改时间是否比 filename2 的新。</td></tr><tr><td align="center">filename -ot filename2</td><td align="center">判断 filename1 的修改时间是否比 filename2 的旧。</td></tr><tr><td align="center">filename1 -ef filename2</td><td align="center">判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td></tr></tbody></table><p>Shell 提供了与<code>-a</code>、或<code>-o</code>、非<code>!</code>三个逻辑操作符用于将测试条件连接起来，其优先级为： <code>!</code> 最高， <code>-a</code> 次之， <code>-o</code> 最低。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./sh -a -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个shell脚本解释器都有&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;有一个没有或者两个shell脚本解释器都没有&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>[]</code>可以代替test做判断的功能，在使用的时候需要左右两边都空开，</p><p><code>(())</code>及<code>[[]]</code> :它们分别是<code>[]</code>的针对数学比较表达式和字符串表达式的加强版。其中<code>(())</code>，不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号：</p><img src="/2023/09/28/Linux/Shell%E8%84%9A%E6%9C%AC/v2-4585b7d2ef9300917868e52783961957_r.jpg" class><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> [ -e ./sh -a -e ./bash ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个shell脚本解释器都有&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;有一个没有或者两个shell脚本解释器都没有&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>控制语句</strong></p><ul><li><p>条件控制语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if else</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if else-if else</span></span><br><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> == <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &gt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &lt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;没有符合的条件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>选择语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于其他语言里的switch</span></span><br><span class="line"><span class="keyword">case</span> value <span class="keyword">in</span></span><br><span class="line">mode1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">mode2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入你的成绩&#x27;</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    6?)  <span class="built_in">echo</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    7?)  <span class="built_in">echo</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    8?)  <span class="built_in">echo</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    9?)  <span class="built_in">echo</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    100) <span class="built_in">echo</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">&#x27;E&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><ul><li><p>for循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种用法和c语言类似</span></span><br><span class="line"><span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第二种用法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 单词表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种用法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> &#123;n..m&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四种用法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> `<span class="built_in">command</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">for</span> (( ; ; ))</span><br></pre></td></tr></table></figure></li><li><p>while循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本用法</span></span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var=1</span><br><span class="line"><span class="keyword">while</span>((var &lt; <span class="number">10</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">((var++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>until 循环</p><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p><p>until 语法格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> [ ! <span class="variable">$a</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   a=`<span class="built_in">expr</span> <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>跳出循环</p><p>与C语言一样，shell脚本也可以用<code>break</code>结束循环，或者<code>continue</code>结束本次循环进行下一次循环。</p></li></ul></li></ul><h2 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h2><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。与大部分编程语言类似，数组元素的下标由 0 开始。</p><p>Shell 数组用括号来表示，元素用”空格”符号分割开，如果一个元素想赋值多个用空格隔开的字符串，需要将这些字符串用双引号 <code>&quot;&quot;</code> 包裹起来，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 value2 ... valuen)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">arr=(A B <span class="string">&quot;hello world&quot;</span> D)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line">arr[0]=A</span><br><span class="line">arr[1]=B</span><br><span class="line">arr[2]=<span class="string">&quot;hello world&quot;</span></span><br><span class="line">arr[3]=D</span><br></pre></td></tr></table></figure><p><strong>关联数组</strong></p><p>Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。</p><p>关联数组使用 <code>declare</code> 命令来声明，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A array_name</span><br></pre></td></tr></table></figure><p><code>-A</code> 选项就是用于声明一个关联数组。关联数组的键是唯一的。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A arr=([<span class="string">&quot;google&quot;</span>]=<span class="string">&quot;www.google.com&quot;</span> [<span class="string">&quot;runoob&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span> [<span class="string">&quot;taobao&quot;</span>]=<span class="string">&quot;www.taobao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以先声明再定义</span></span><br><span class="line"><span class="built_in">declare</span> -A site</span><br><span class="line">site[<span class="string">&quot;google&quot;</span>]=<span class="string">&quot;www.google.com&quot;</span></span><br><span class="line">site[<span class="string">&quot;runoob&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">site[<span class="string">&quot;taobao&quot;</span>]=<span class="string">&quot;www.taobao.com&quot;</span></span><br></pre></td></tr></table></figure><p><strong>读取数组元素</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>遍历数组元素</strong></p><p>使用 <code>@</code> 或 <code>*</code> 可以获取数组中的所有元素。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[0]=A</span><br><span class="line">arr[1]=B</span><br><span class="line">arr[2]=C</span><br><span class="line">arr[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的元素为: <span class="variable">$&#123;arr[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的元素为: <span class="variable">$&#123;arr[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>获取数组的键</strong></p><p>在数组前加一个感叹号 <code>!</code> 可以获取数组的所有键。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A arr=([<span class="string">&quot;google&quot;</span>]=<span class="string">&quot;www.google.com&quot;</span> [<span class="string">&quot;runoob&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span> [<span class="string">&quot;taobao&quot;</span>]=<span class="string">&quot;www.taobao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的键为: <span class="variable">$&#123;!arr[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的键为: <span class="variable">$&#123;!arr[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>获取数组的长度</strong></p><p>获取数组长度的方法与获取字符串长度的方法相同。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[0]=A</span><br><span class="line">arr[1]=B</span><br><span class="line">arr[2]=C</span><br><span class="line">arr[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组元素个数为: <span class="variable">$&#123;#arr[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组元素个数为: <span class="variable">$&#123;#arr[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>没有数据类型，没有形参，但是可以传参。函数里面定义的变量都是全局变量，但是变量在函数调用之后才会生效，定义局部变量local。<br>一般形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func_name()<span class="comment"># function关键字可以没有</span></span><br><span class="line">&#123;</span><br><span class="line">   func_body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的调用：函数名</li><li>函数返回值：可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）。函数返回值在调用该函数后通过 <code>$?</code> 来获得（0~255，超过就从0开始循环）。需要注意的是，<code>$?</code> 的值是上一条命令的返回状态，如果函数调用后不是立即用 <code>$?</code> 接收函数的返回值，而是插入了别的命令，那么 <code>$?</code> 接收到的返回值就不是函数的返回值了。</li><li>函数的传参：<code>函数名 实参1 实参2 实参3...</code>参数之间用空格隔开，在函数里面从<code>$1</code>开始接收传参</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span> <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span><span class="comment"># 2 </span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span><span class="comment"># 10</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span>     <span class="comment"># 11</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 256</span><br><span class="line">&#125;</span><br><span class="line">func 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">return</span> is $? <span class="comment"># 这里的 $? 是0，因为返回值是256超过了255，重新从0开始</span></span><br></pre></td></tr></table></figure><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make</title>
      <link href="/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Make/"/>
      <url>/2023/09/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Make/</url>
      
        <content type="html"><![CDATA[<h2 id="Make介绍"><a href="#Make介绍" class="headerlink" title="Make介绍"></a>Make介绍</h2><p>使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Visual C++的nmake，QtCreator的qmake等。</p><p>make工具在构造项目的时候需要加载一个叫做makefile的文件，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>makefile文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。</p><p>Make命令执行时，默认情况下make 会在当前目录下按顺序找寻名字为：GNUmakefile、makefile、Makefile 中的一个解释文件（建议用Makefile）。如果要指定makefile 可以加上-f参数，如下所示</p><blockquote><p>make -f makefile_filename</p></blockquote><h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>makefile每条规则的语法格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target1,target2...: depend1, depend2, ...</span><br><span class="line">command</span><br></pre></td></tr></table></figure><p>每条规则由三个部分组成分别是目标(target), 依赖(depend)和命令(command)。</p><ul><li><p>目标(target)： 规则中的目标，这个目标和规则中的命令是对应的</p><ul><li><p>通过执行规则中的命令，可以生成一个和目标同名的文件</p></li><li><p>规则中可以有多个命令, 因此可以通过这多条命令来生成多个目标, 所有目标也可以有很多个</p></li><li><p>通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为伪目标</p></li></ul></li><li><p>依赖(depend): 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。</p><ul><li>例如：生成可执行文件的目标文件（*.o）可以作为依赖使用</li><li>如果规则的命令中不需要任何依赖，那么规则的依赖可以为空</li><li>当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套</li><li>依赖可以根据要执行的命令的实际需求, 指定很多个</li></ul></li><li><p>命令(command): 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令</p><ul><li>例如：通过某个命令编译文件、生成库文件、进入目录等。</li><li>动作可以是多个，每个命令前必须有一个Tab缩进并且独占占一行。</li></ul></li></ul><h2 id="Make工作原理"><a href="#Make工作原理" class="headerlink" title="Make工作原理"></a>Make工作原理</h2><blockquote><p>在此主要为大家剖析一下通过提供的 makefile 文件，构建工具 make 什么时候编译项目中的所有文件, 什么时候只选择更新项目中的某几个文件。另外再研究一下如果makefile里边有多个规则它们之间是如何配合工作的。</p></blockquote><h3 id="规则的执行"><a href="#规则的执行" class="headerlink" title="规则的执行"></a>规则的执行</h3><p>​在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但是需要注意的是，好多时候要执行的动作（命令）中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p><p>​对应的解决方案是先将需要的依赖生成出来，我们就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p><p>​这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有test.o这个依赖，make会向下寻找是否有规则产生了这个依赖</span></span><br><span class="line"><span class="section">test:test.o</span></span><br><span class="line">gcc test.o -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure><p><strong>执行指定规则：</strong></p><p>​如果想要执行 makefile 中非第一条规则对应的命令, 那么就不能直接 make, 需要将那条规则的目标也写到make的后边, 比如只需要执行生成test.o的命令, 就需要: make test.o。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如删除中间文件、程序的打包、程序的备份等等，然后把这些命令放在一个伪目标后，这样就可以通过<code>make 伪目标名</code>来执行这些命令了。</p><h3 id="文件的时间戳"><a href="#文件的时间戳" class="headerlink" title="文件的时间戳"></a>文件的时间戳</h3><p>make 命令执行的时候会根据文件的时间戳判定是否执行makefile文件中相关规则中的命令。</p><p>​目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳, 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件, 那么规则中的命令就不会被执行。<br>当依赖文件被更新了, 文件时间戳也会随之被更新, 这时候 目标时间戳 &lt; 某些依赖的时间戳, 在这种情况下目标文件会通过规则中的命令被重新生成。<br>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</p><h3 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h3><p>make 是一个功能强大的构建工具，虽然make需要根据 makefile 中指定的规则来完成源文件的编译。作为小白的我们编写makefile的时候难免写的不是那么严谨从而漏写一些构建规则，但是我们会发现程序还是会被编译成功。这是因为 make 有自动推导的能力，不会完全依赖 makefile。</p><p>比如: 使用命令 make 编译扩展名为.c 的 C 语言文件的时候，源文件的编译规则不用明确给出。这是因为 make 进行编译的时候会使用一个默认的编译规则，按照默认规则完成对.c文件的编译，生成对应的.o 文件。它使用命令<code>cc -c</code>来编译.c 源文件。在 Makefile 中只要给出需要构建的目标文件名（一个.o 文件），make 会自动为这个.o 文件寻找合适的依赖文件（对应的.c 文件），并且使用默认的命令来构建这个目标文件。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile中的变量分为三种：自定义变量，预定义变量和自动变量。</p><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。需要注意的是，创建变量后必须为其赋值。</p><p><strong>变量赋值</strong></p><ul><li><p>普通赋值，在给b变量赋a变量时，b变量会先被赋a变量的当前值，之后b变量会随a变量的改变而改变</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=$a</span><br><span class="line">a=20</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#20</span></span><br><span class="line">@echo $b<span class="comment">#20</span></span><br></pre></td></tr></table></figure></li><li><p>立即赋值，在给b变量赋a变量时，b变量会先被赋a变量的当前值，之后b变量不会随a变量的改变而改变</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b:=$a</span><br><span class="line">a=20</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#20</span></span><br><span class="line">@echo $b<span class="comment">#10</span></span><br></pre></td></tr></table></figure></li><li><p>询问赋值，在给b变量赋值时，会查看b变量在前面是否有赋值，如果有，此时赋值无效</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b:=$a</span><br><span class="line">b?=20</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#10</span></span><br><span class="line">@echo $b<span class="comment">#10</span></span><br></pre></td></tr></table></figure></li><li><p>追加赋值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b:=$a</span><br><span class="line">a+=hxy is cool boy</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#10 hxy is cool b</span></span><br><span class="line">@echo $b<span class="comment">#10</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建变量obj target</span></span><br><span class="line">obj=main.o  mult.o  sub.o</span><br><span class="line">target=test</span><br><span class="line"><span class="comment"># 取出变量用$(变量名)</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：</p><table><thead><tr><th align="center">变 量 名</th><th align="center">含 义</th><th align="center">默 认 值</th></tr></thead><tbody><tr><td align="center">AR</td><td align="center">生成静态库库文件的程序名称</td><td align="center">ar</td></tr><tr><td align="center">AS</td><td align="center">汇编编译器的名称</td><td align="center">as</td></tr><tr><td align="center">CC</td><td align="center">C 语言编译器的名称</td><td align="center">cc</td></tr><tr><td align="center">CPP</td><td align="center">C 语言预编译器的名称</td><td align="center">$(CC) -E</td></tr><tr><td align="center">CXX</td><td align="center">C++语言编译器的名称</td><td align="center">g++</td></tr><tr><td align="center">FC</td><td align="center">FORTRAN 语言编译器的名称</td><td align="center">f77</td></tr><tr><td align="center">RM</td><td align="center">删除文件程序的名称</td><td align="center">rm -f</td></tr><tr><td align="center">ARFLAGS</td><td align="center">生成静态库库文件程序的选项</td><td align="center">无默认值</td></tr><tr><td align="center">ASFLAGS</td><td align="center">汇编语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CFLAGS</td><td align="center">C 语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CPPFLAGS</td><td align="center">C 语言预编译的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CXXFLAGS</td><td align="center">C++语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">FFLAGS</td><td align="center">FORTRAN 语言编译器的编译选项</td><td align="center">无默认值</td></tr></tbody></table><p><strong>GCC编译选项CFLAGS参数</strong></p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">用于把源码文件编译成 .o 对象文件,不进行链接过程</td></tr><tr><td align="center">-o</td><td align="center">用于连接生成可执行文件，在其后可以指定输出文件的名称</td></tr><tr><td align="center">-g</td><td align="center">用于在生成的目标可执行文件中，添加调试信息，可以使用GDB进行调试</td></tr><tr><td align="center">-Idir</td><td align="center">用于把新目录添加到include路径上，可以使用相对和绝对路径，“-I.”、“-I.&#x2F;include”、“-I&#x2F;opt&#x2F;include”</td></tr><tr><td align="center">-Wall</td><td align="center">生成常见的所有告警信息，且停止编译，具体是哪些告警信息，请参见GCC手册，一般用这个足矣！</td></tr><tr><td align="center">-w</td><td align="center">关闭所有告警信息</td></tr><tr><td align="center">-O</td><td align="center">表示编译优化选项，其后可跟优化等级0\1\2\3，默认是0，不优化</td></tr><tr><td align="center">-fPIC</td><td align="center">用于生成位置无关的代码</td></tr><tr><td align="center">-v</td><td align="center">(在标准错误stderr)显示执行编译阶段的命令，同时显示编译器驱动程序,预处理器,编译器的版本号</td></tr></tbody></table><p><strong>GCC链接选项LDFLAGS参数</strong></p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-llibrary</td><td align="center">链接时在标准搜索目录中寻找库文件，搜索名为liblibrary.a 或 liblibrary.so</td></tr><tr><td align="center">-Ldir</td><td align="center">用于把新目录添加到库搜索路径上，可以使用相对和绝对路径，“-L.”、“-L.&#x2F;include”、“-L&#x2F;opt&#x2F;include”</td></tr><tr><td align="center">-Wl,option</td><td align="center">把选项 option 传递给连接器，如果 option 中含有逗号,就在逗号处分割成多个选项</td></tr><tr><td align="center">-static</td><td align="center">使用静态库链接生成目标文件，避免使用共享库，生成目标文件会比使用动态链接库大</td></tr></tbody></table><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。下表中是一些常见的自动变量：</p><table><thead><tr><th align="center">变量</th><th align="center">含 义</th></tr></thead><tbody><tr><td align="center">$*</td><td align="center">表示目标文件的名称，不包含目标文件的扩展名</td></tr><tr><td align="center">$+</td><td align="center">表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能包含重复的依赖文件</td></tr><tr><td align="center">$&lt;</td><td align="center">表示依赖项中第一个依赖文件的名称</td></tr><tr><td align="center">$?</td><td align="center">依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td></tr><tr><td align="center">$@</td><td align="center">表示目标文件的名称，包含文件扩展名</td></tr><tr><td align="center">$^</td><td align="center">依赖项中，所有不重复的依赖文件，这些文件之间以空格分开</td></tr></tbody></table><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名</span></span><br><span class="line"><span class="comment"># 下面这条规则会不断执行，直到所有.c文件都被编译为.o文件，%对应的文件名时刻在变化，所以需要用自动变量$&lt;</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>makefile中有很多函数并且所有的函数都是有返回值的。makefile中函数的写法是这样的：<code> $(函数名 参数1, 参数2, 参数3, ...)</code>，主要目的是让我们能够快速方便的得到函数的返回值。</p><p>这里为大家介绍两个 makefile 中使用频率比较高的函数：wildcard和patsubst。</p><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><p>这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔</span></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br><span class="line">参数:指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c</span><br></pre></td></tr></table></figure><ul><li>参数功能:<ul><li>PATTERN 指的是某个或多个目录下的对应的某种类型的文件, 比如当前目录下的.c文件可以写成 *.c<br>可以指定多个目录，每个路径之间使用空格间隔。</li></ul></li><li>返回值：<ul><li>得到的若干个文件的文件列表， 文件名之间使用空格间隔<br>示例：<code>$(wildcard *.c ./sub/*.c)</code><br>返回值格式：<code>a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c</code></li></ul></li></ul><p><strong>函数使用举例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/hxy/a/*.c /home/hxy/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure><h3 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h3><p>这个函数的功能是按照指定的模式替换指定的文件名的后缀, 函数原型如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有三个参数, 参数之间使用 逗号间隔</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>参数功能:</p><ul><li><p>pattern: 这是一个模式字符串, 需要指定出要被替换的文件名中的后缀是什么</p><ul><li>文件名和路径不需要关心, 因此使用 % 表示即可 [通配符是 %]</li><li>在通配符后边指定出要被替换的后缀, 比如: %.c, 意味着 .c的后缀要被替换掉</li></ul></li><li><p>replacement: 这是一个模式字符串, 指定参数pattern中的后缀最终要被替换为什么</p><ul><li>还是使用 % 来表示参数pattern 中文件的路径和名字</li><li>在通配符 % 后边指定出新的后缀名, 比如: %.o 这表示原来的后缀被替换为 .o</li></ul></li><li><p>text: 该参数中存储这要被替换的原始数据</p></li></ul></li><li><p>返回值:</p><ul><li>函数返回被替换过后的字符串。</li></ul></li></ul><p><strong>函数使用举例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure><h2 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h2><p>以下是一个makefile示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-Wall -O2 -g -std=gnu99 -pthread -I./inc</span><br><span class="line">LDFALGS= -L./lib -lseqlist</span><br><span class="line">CC=gcc</span><br><span class="line">APP=test</span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span> <span class="variable">$^</span> <span class="variable">$(CFALGS)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$(APP)</span> <span class="variable">$(CFALGS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean # 声明clean是个伪目标，即使当前目录有clean也不会受影响</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o run</span><br></pre></td></tr></table></figure><p><strong>伪目标：</strong></p><p>​以<code>make clean</code>为例，因为我们并不生成 clean 这个文件。所以伪目标只是一个标签，由于伪目标不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个目标才能让其生效。当然，伪目标的取名不能和文件名重名，不然其就失去了伪目标的意义了。因此，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记<code>.PHONY</code>来显示地指明一个目标是伪目标，向make说明，不管是否有这个文件，这个目标就是伪目标。<code>.PHONY : clean</code>只要有这个声明，不管是否有<code>clean</code>文件，要运行<code>clean</code>这个目标，只有<code>make clean</code>这样。伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为默认目标，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:app1 app2</span></span><br><span class="line"><span class="section">app1:test1.c</span></span><br><span class="line">gcc test1.c -o app1</span><br><span class="line"><span class="section">app2:test2.c</span></span><br><span class="line">gcc test2.c -o app2</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm app1 app2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/2023/09/28/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/09/28/Linux/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>下面是 Linux 常用命令的简单介绍。但实际上，Linux 命令的种类和功能还有很多，每个命令都有许多参数和选项，在这就不一一介绍，需要的朋友可以自行网上查找相关资料。</p><p><strong>文件和目录操作命令</strong></p><ul><li>ls：列出当前目录中的文件和子目录。</li><li>cd：切换当前工作目录。</li><li>mkdir：创建一个新的目录。</li><li>rmdir：删除一个空目录。</li><li>touch：创建一个新文件，或者更新已有文件的时间戳。</li><li>cp：复制文件或目录。</li><li>mv：移动或重命名文件或目录。</li><li>rm：删除文件或目录。</li><li>chmod：修改文件或目录的访问权限。</li><li>chown：修改文件或目录的所有者。</li><li>chgrp：修改文件或目录的所属群组。</li></ul><p><strong>文件查看和编辑命令</strong></p><ul><li><p>cat：从头开始显示文件内容。</p></li><li><p>more：逐屏显示文件内容，用空格键翻页，按 Q 键退出。</p></li><li><p>less：类似于 more 命令，但比 more 更强大，提供了快速搜索和定位等功能。</p></li><li><p>tail：显示文件的最后几行。</p></li><li><p>head：显示文件的头几行。</p></li><li><p>vim：一个常用的文本编辑器，支持命令模式、插入模式和可视模式等多种编辑方式。</p></li></ul><p><strong>系统管理命令</strong></p><ul><li>ps：查看当前运行进程的情况。</li><li>top：展示系统当前运行的进程、资源占用情况等信息。</li><li>kill：向指定进程发送信号，以停止、暂停或重新启动该进程。</li><li>df：查看磁盘空间使用情况。</li><li>du：查看目录中文件大小的统计信息。</li><li>ping：检测网络连接是否正常，测试主机与目的计算机之间的响应时间。</li><li>ifconfig：配置网络接口的 IP 地址、掩码等参数。</li><li>netstat：展示网络连接、路由表、网络接口等信息。</li><li>ssh：安全地登录远程主机并执行命令。</li><li>sudo：以超级用户身份执行命令。</li><li>tar：对文件和目录进行压缩和解压缩操作。</li><li>scp：使用 SSH 协议，将文件从本地复制到远程主机或将远程主机上的文件复制到本地。</li></ul><p><strong>curl 命令</strong></p><p>用于使用 URL 获得文件并将其输出到标准输出。常用参数如下：</p><ul><li>curl -O <a href="https://example.com/file.txt%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6">https://example.com/file.txt：将文件</a> <a href="https://example.com/file.txt">https://example.com/file.txt</a> 下载到当前目录。</li></ul><p><strong>wget 命令</strong></p><p>也用于下载文件。常用参数如下：</p><ul><li>wget <a href="https://example.com/file.txt%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6">https://example.com/file.txt：将文件</a> <a href="https://example.com/file.txt">https://example.com/file.txt</a> 下载到当前目录。</li></ul><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>离线下载<br>下载：<code>sudo dpkg -i软件包名</code>：下载软件包<br>卸载：<code>sudo dpkg -r软件名</code>：卸载<br>优势：不用去找依赖文件，下载速度快</p><p>在线下载<br>下载：<code>sudo apt-get install 软件名</code><br>卸载：<code>sudo apt-get remove 软件名</code><br>需要联网，也需要找依赖文件，下载较慢</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li><p>通配符：</p><ul><li><p><code>*</code>：通配所有字符</p></li><li><p><code>&#123;n..m&#125;</code>:通配连续的n到m之间的字符，包括本身</p></li><li><p><code>[]</code>：通配一个字符</p></li><li><p><code>[12345abc]</code>：通配里面存在的字符</p></li><li><p><code>[1-5]</code>：通配连续的字符</p></li><li><p><code>[^a]</code>:通配除5以外的字符</p></li><li><p><code>?</code>：通配一个字符</p></li></ul></li><li><p>输入输出重定向：</p><ul><li><code>&gt;</code>   :覆盖赋值</li><li><code>&gt;&gt;</code>：追加赋值</li></ul></li><li><p>管道|：<code>命令1 | 命令2</code>把命令1的输出作为命令2的输入</p></li><li><pre><code class="tex">命令置换符``命令1 `命令2`:把命令2的输出作为命令1的参数</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC</title>
      <link href="/2023/09/27/Linux/GCC/"/>
      <url>/2023/09/27/Linux/GCC/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h2><p>&emsp;&emsp;GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Objective-C、Fortran、Ada、GoFortran 和 Java 以及各类处理器架构上的汇编语言，GCC还包括了这些语言的库（如libstdc++，libgcj等。）。 因此，GCC也被重新定义为“GNU Compiler Collection”，成为历史上最优秀的编译器套件， 其执行效率与一般的编译器相比平均效率要高 20%~30%。</p><p>​GCC由一系列的编译器和工具集（例如ar、nm等）组成，每个编译器都用于处理特定的编程语言。其中最常用的是GCC的C编译器（gcc）和C++编译器（g++）。这两个编译器可以将C和C++源代码编译成可执行文件或库文件。</p><p>​GCC提供了丰富的编译选项和优化功能，可以根据需要进行配置和调整。它支持多种目标平台和操作系统，包括Linux、Windows、macOS等。GCC还支持多种架构和处理器，如x86、ARM、MIPS等。</p><h2 id="GCC编译工具链"><a href="#GCC编译工具链" class="headerlink" title="GCC编译工具链"></a>GCC编译工具链</h2><p>GCC编译工具链（toolchain），是指以GCC编译器为核心的一整套工具。它主要包含以下三部分内容：</p><ul><li>gcc-core：即GCC编译器，用于完成预处理和编译过程，把C代码转换成汇编代码。</li><li>Binutils ：除GCC编译器外的一系列小工具包括了链接器ld，汇编器as、目标文件格式查看器readelf等。</li><li>glibc：包含了主要的 C语言标准函数库，C语言中常常使用的打印函数printf、malloc函数就在glibc 库中。</li></ul><p>在很多场合下会直接用GCC编译器来指代整套GCC编译工具链。</p><h2 id="gcc基本用法"><a href="#gcc基本用法" class="headerlink" title="gcc基本用法"></a>gcc基本用法</h2><p>GCC最基本的用法是∶gcc [options] [filenames]</p><p>其中options就是编译器所需要的参数，filenames给出相关的文件名称。下面是一些常用gcc参数：</p><ul><li>-c，只编译，不链接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常用于编译不包含主程序的子程序文件。</li><li>-o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出预设的可执行文件a.out。</li><li>-g，产生符号调试工具（GNU的gdb）所必要的符号资讯，要想对源代码进行调试，我们就必须加入这个选项。</li><li>-O，对程序进行优化编译、链接，采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、链接的速度就相应地要慢一些。</li><li>-O2，比-O更好的优化编译、链接，当然整个编译、链接过程会更慢。</li><li>-Idirname，将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。C程序中的头文件包含两种情况∶<ul><li>#include &lt;&gt; ：专门用来包含系统提供的头文件（由操作系统自带的，不是程序员自己写的）。编译器只会到系统指定目录去寻找这个头文件，也可以用-I附加指定其他的包含路径。</li><li>#include “”  ：用来包含自己写的头文件，编译器默认先在当前目录下寻找相应的头文件，如果没找到再到系统指定的目录去寻找，也可以用-I附加指定其他的包含路径。</li></ul></li><li>-v gcc执行时执行的详细过程，gcc及其相关程序的版本号</li></ul><h2 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h2><p>​对于C语言程序，我们需要将它编译链接为可执行的二进制文件，然后由系统加载执行。在Linux系统中，GCC编译程序会读取源代码文件，并且将其翻译成一个可执行文件，整个过程共四个阶段，由编译工具链完成。下面将详细介绍这四个过程。</p><h3 id="预处理（cpp）"><a href="#预处理（cpp）" class="headerlink" title="预处理（cpp）"></a>预处理（cpp）</h3><p>在命令行下输入<code>gcc -E test.c -o test.i</code>，预处理器会对以#开头的预处理命令进行处理，如读取头文件、宏替换等。在这之后会得到一个新的C程序，我们一般将其命名为.i文件。</p><p>编译器本身的主要目的是编译源代码，将C语言的源代码转化成.s的汇编代码。编译器聚焦核心功能后，剥离出的一部分非核心功能由预处理器执行。预处理器对源代码进行一些预先处理，为后续编译打好基础后，再由编译器编译。</p><p>预处理器涉及的内容：</p><ul><li>文件包含</li><li>宏定义</li><li>条件编译</li><li>一些特殊的预处理关键字</li><li>去掉程序中的注释</li></ul><p><strong>test.i如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">858</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __uflow (FILE *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br><span class="line"># <span class="number">873</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译（cc）"><a href="#编译（cc）" class="headerlink" title="编译（cc）"></a>编译（cc）</h3><p>在命令行下输入<code>gcc -S test.i -o test.s</code>，当然也可以是<code>gcc -S test.c -o test.s</code>，只是这种方式是由预处理器和编译器一起完成的，编译器将test.i翻译成了test.s汇编文件，汇编程序是一条条通用的机器语言指令。</p><p><strong>test.s如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;test.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;test&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">endbr64</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">leaq.LC0(%rip), %rdi</span><br><span class="line">callputs@PLT</span><br><span class="line">movl$0, %eax</span><br><span class="line">popq%rbp</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">.section.note.gnu.property,&quot;a&quot;</span><br><span class="line">.align 8</span><br><span class="line">.long 1f - 0f</span><br><span class="line">.long 4f - 1f</span><br><span class="line">.long 5</span><br><span class="line">0:</span><br><span class="line">.string &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">.align 8</span><br><span class="line">.long 0xc0000002</span><br><span class="line">.long 3f - 2f</span><br><span class="line">2:</span><br><span class="line">.long 0x3</span><br><span class="line">3:</span><br><span class="line">.align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure><h3 id="汇编（as）"><a href="#汇编（as）" class="headerlink" title="汇编（as）"></a>汇编（as）</h3><p>在命令行下输入<code>gcc -c test.s -o test.o</code>，汇编器会将test.s翻译成机器语言指令，将这些指令打包为***.o格式的可重定位文件，并将结果保存在目标文件test.o中。目标文件是由不同的段组成，通常一个目标至少有两个段：数据段和代码段。hello.o用文本文档打开后是无法看懂的，因为这是二进制文件。</p><h3 id="链接（ld）"><a href="#链接（ld）" class="headerlink" title="链接（ld）"></a>链接（ld）</h3><p>在命令行下输入<code>gcc test.o -o test</code>，链接器会将test.o和其他库文件、目标代码链接后形成可执行文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2023/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>​策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据需要选择算法的行为。它通过将算法封装在独立的策略类中，并让客户端根据需要选择不同的策略类来实现不同的行为。</p><p>​策略模式的主要目的是将算法的定义与使用分离，使得算法的变化不会影响到使用算法的客户端。它通过定义一个公共的接口或基类来表示所有的策略类，然后每个具体的策略类都实现该接口或继承该基类，并提供自己的算法实现。</p><p>下面是一个使用策略模式的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy1</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing strategy 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy2</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing strategy 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : <span class="built_in">strategy</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体策略对象</span></span><br><span class="line">    ConcreteStrategy1 strategy1;</span><br><span class="line">    ConcreteStrategy2 strategy2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建上下文对象，并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(&amp;strategy1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    context.<span class="built_in">executeStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(&amp;strategy2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行新的策略</span></span><br><span class="line">    context.<span class="built_in">executeStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个策略接口（Strategy），其中包含了一个纯虚函数execute()，用于执行具体的算法。</p><p>然后，我们创建了两个具体的策略类（ConcreteStrategy1和ConcreteStrategy2），它们分别实现了Strategy接口，并提供了自己的算法实现。</p><p>接下来，我们定义了一个上下文类（Context），它包含了一个指向Strategy对象的指针，并提供了设置策略和执行策略的方法。</p><p>在main函数中，我们先创建了具体的策略对象strategy1和strategy2，然后创建了上下文对象context，并将初始策略设置为strategy1。接着，我们调用context的executeStrategy()方法来执行策略。</p><p>然后，我们通过调用context的setStrategy()方法将策略切换为strategy2，并再次调用executeStrategy()方法来执行新的策略。</p><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executing strategy 1</span><br><span class="line">Executing strategy 2</span><br></pre></td></tr></table></figure><p>这个示例展示了策略模式的基本用法，它允许在运行时动态地选择不同的策略来实现不同的行为。这种灵活性使得策略模式在需要根据不同的条件选择算法时特别有用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2023/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>​代理模式（Proxy Pattern）是一种结构型设计模式，它允许通过创建一个代理对象来控制对另一个对象的访问。代理对象充当了另一个对象的接口，以便可以通过代理对象来访问另一个对象，同时可以在访问另一个对象之前或之后执行一些额外的操作。</p><p>​代理模式的主要目的是提供一种间接访问另一个对象的方式，以便可以在访问对象之前或之后执行一些额外的操作，例如权限控制、缓存、延迟加载等。</p><p>下面是一个使用代理模式的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject1</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RealSubject1: Handling request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject2</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RealSubject2: Handling request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProxy</span><span class="params">(Subject* subject)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在访问真实主题之前执行一些额外的操作</span></span><br><span class="line"><span class="keyword">if</span> (subject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;subject is nullptr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用真实主题处理请求</span></span><br><span class="line">subject-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在访问真实主题之后执行一些额外的操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RealSubject1 RealSubject1;</span><br><span class="line">RealSubject2 RealSubject2;</span><br><span class="line">Proxy proxy;</span><br><span class="line">proxy.<span class="built_in">setProxy</span>(&amp;RealSubject1);</span><br><span class="line">proxy.<span class="built_in">setProxy</span>(&amp;RealSubject2);</span><br><span class="line">proxy.<span class="built_in">setProxy</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">catch</span>(<span class="type">const</span> exception &amp; err) &#123;</span><br><span class="line">std::cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个主题接口（Subject），其中包含一个纯虚函数request()，用于处理请求。</p><p>然后，我们创建了一个真实主题类（RealSubject），它实现了Subject接口，并提供了真正的请求处理逻辑。</p><p>接下来，我们定义了一个代理类（Proxy），它也实现了Subject接口，并包含一个指向RealSubject对象的指针。</p><p>在代理类的request()方法中，我们在访问真实主题之前执行一些额外的操作（例如创建真实主题对象），然后使用真实主题对象处理请求，最后在访问真实主题之后执行一些额外的操作。</p><p>在main函数中，我们创建了一个代理对象proxy，并使用它来处理请求。代理对象会在访问真实主题之前执行额外的操作，并将请求传递给真实主题对象来处理。</p><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealSubject: Handling request.</span><br></pre></td></tr></table></figure><p>这个示例展示了代理模式的基本用法，它允许通过创建一个代理对象来控制对另一个对象的访问，并在访问对象之前或之后执行一些额外的操作。代理模式在需要对访问进行控制或添加一些额外的功能时特别有用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是指某个类有且仅有一个实例。为了不再增加其他实例，应做以下处理：</p><ol><li>构造函数私有化<ul><li>由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。</li><li>由于静态对象的访问权限是private，类外如果想要使用这个静态的单例对象，单例类中就需要提供一个public接口。类中只有它的静态成员函数才能访问其静态成员变量，所以这个单例类的public接口是一个静态函数。</li></ul></li><li>拷贝构造函数私有化或者禁用（ &#x3D; delete）</li><li>拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）</li></ol><p><strong>示例代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个单例模式的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="type">static</span> Singleton* m_obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">m_obj = <span class="keyword">new</span> Singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Singleton &amp;s) &#123;</span><br><span class="line">out &lt;&lt; s.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.c &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_obj = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Singleton *ptr = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">ptr-&gt;a = <span class="number">10</span>;</span><br><span class="line">ptr-&gt;b = <span class="number">20</span>;</span><br><span class="line">ptr-&gt;c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：类的静态成员变量在使用之前必须在类的外部进行初始化才能使用。</p><p><strong>存在的问题和改进</strong></p><p>​在调用getInstance()函数获取单例对象的时候，如果在单线程情况下是没有什么问题的，如果是多个线程，调用这个函数去访问单例对象就有问题了。假设有三个线程同时执行了getInstance()函数，在这个函数内部每个线程都会new出一个实例对象。此时，这个任务队列类的实例对象不是一个而是3个，很显然这与单例模式的定义是相悖的。</p><p>​使用锁机制可以解决上述问题，但是如果同时访问的线程过多会造成卡顿，此时就需要在加锁之前再加上一个判断，判断单例是否已被创建。如果已创建则无需进行后续操作，也就不需要加锁了（双重检查锁）。但是在单例未创建时还是会存在上述问题，所以最好在类加载的时候就对单例进行实例化（饿汉模式）。饿汉模式也有个缺点，就是如果单例并不会立即使用，则会浪费空间，但对于现代电脑来说，一点空间无关紧要。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
