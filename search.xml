<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>man</title>
      <link href="/2023/09/29/man/"/>
      <url>/2023/09/29/man/</url>
      
        <content type="html"><![CDATA[<img src="/2023/09/29/man/image-20230929230030510.png" class>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/09/28/Git/"/>
      <url>/2023/09/28/Git/</url>
      
        <content type="html"><![CDATA[<p>​Git是目前最流行的分布式版本控制系统之一。它被广泛用于管理软件和其他文本文件的版本控制，并协助多人协同开发。Git由Linux操作系统的内核创始人Linus Torvalds在2005年创造，以处理其自己的内部版本管理需求。自那时起，Git已经成为一个重要的工具，被许多公司和开源项目用来维护代码库、跟踪更改并记录历史。</p><h2 id="1-初始化配置"><a href="#1-初始化配置" class="headerlink" title="1. 初始化配置"></a>1. 初始化配置</h2><p>使用 git config 命令配置用户名和邮箱，只用执行一次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置用户名,有空格需要加上双引号</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Huang Xiaoyu&quot;</span></span><br><span class="line"><span class="comment">#--Local 参数(省略) : 本地配置，只对本地仓库有效。</span></span><br><span class="line"><span class="comment">#--global 参数 : 全局配置。所有仓库生效。</span></span><br><span class="line"><span class="comment">#--system 参数 : 系统配置，对所有用户生效。</span></span><br><span class="line"><span class="comment">#配置邮箱,没有空格不用加上双引号</span></span><br><span class="line">git config --global user.email 1442340493@qq.com</span><br><span class="line"><span class="comment">#保存用户名和密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"><span class="comment">#查看配置信息</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h2 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2. 新建仓库"></a>2. 新建仓库</h2><p><strong>方式一：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先创建一个空目录</span></span><br><span class="line"><span class="built_in">mkdir</span> learn-git</span><br><span class="line"><span class="built_in">cd</span> learn-git</span><br><span class="line"><span class="comment">#创建仓库，会生成一个.git的隐藏目录，使用ls -a可以查看，里面的东西不可随意更改，否则会破坏仓库，git init 后面还可以直接加上仓库的名称，这样也会新建一个目录作为git仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在远程服务器(Github  Gitee...)上克隆已经存在的仓库</span></span><br><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure><h2 id="3-工作区域和文件状态"><a href="#3-工作区域和文件状态" class="headerlink" title="3. 工作区域和文件状态"></a>3. 工作区域和文件状态</h2><p>git的本地数据管理分为三个区域：</p><ol><li>工作区（Working Directory）：实际操作的目录。</li><li>暂存区（Staging Area&#x2F;Index）：中间区域，用于临时存放即将提交的修改内容。</li><li>本地仓库（Local Repository）：Git存储代码和版本信息的主要位置。</li></ol><p> git的文件存在四种状态：</p><ol><li>未跟踪（Untrack）：新创建的还未被Git管理起来的文件。</li><li>未修改（Unmodified）：已经被Git管理起来但文件的内容没有发生变化的文件。</li><li>已修改（Modified）：已经修改但还没有添加到暂存区的文件。</li><li>已暂存（Staged）：已经修改也已经添加到暂存区的文件。</li></ol><h2 id="4-添加和提交文件"><a href="#4-添加和提交文件" class="headerlink" title="4. 添加和提交文件"></a>4. 添加和提交文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment">#查看仓库的状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#添加到暂存区</span></span><br><span class="line">git add</span><br><span class="line"><span class="comment">#添加所有文件</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">#查看暂存区内容</span></span><br><span class="line">git ls-files</span><br><span class="line"><span class="comment">#提交</span></span><br><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br><span class="line"><span class="comment"># -a 参数设置修改文件后不需要执行 git add 命令，直接提交</span></span><br><span class="line">git commit -am ”提交信息“</span><br><span class="line"><span class="comment">#查看提交记录 加上 --oneline 参数显示简略信息</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="5-回退版本"><a href="#5-回退版本" class="headerlink" title="5. 回退版本"></a>5. 回退版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br><span class="line"><span class="comment"># --soft 参数:回退到某一个版本，并且保留工作区和暂存区的所有修改内容</span></span><br><span class="line"><span class="comment"># --hard 参数:回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容</span></span><br><span class="line"><span class="comment"># --mixed 默认参数:回退到某一个版本，并且只保留工作区的修改内容而丢弃暂存区的修改内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看历史操作记录</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment">#回退某一操作之前的版本，比如误将工作区、暂存区内容清空。</span></span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><h2 id="6-查看差异"><a href="#6-查看差异" class="headerlink" title="6. 查看差异"></a>6. 查看差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件在工作区、暂存区之间的差异,加上文件名就可以只查看这个文件的差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment">#比较工作区和版本库之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">#比较暂存区和版本库之间的差异</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件在两个特定版本之间的差异，使用HEAD可以表示当前分支的最新提交节点</span></span><br><span class="line">git diff 版本号1 版本号2</span><br><span class="line"><span class="comment">#比较当前版本和上一个版本之间的差异(HEAD~表示HEAD上一个版本，HEAD~2表示HEAD之前两个版本)</span></span><br><span class="line">git diff HEAD~ HEAD</span><br><span class="line">git diff HEAD^ HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件在两个分支之间的差异</span></span><br></pre></td></tr></table></figure><h2 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7. 删除文件"></a>7. 删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 删除工作区和暂存区后直接提交</span></span><br><span class="line"><span class="built_in">rm</span> file3.txt</span><br><span class="line">git add file3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 使用 git rm 后直接提交</span></span><br><span class="line">git <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 删除版本库中的文件</span></span><br><span class="line">git <span class="built_in">rm</span> --cached</span><br></pre></td></tr></table></figure><h2 id="8-忽略文件"><a href="#8-忽略文件" class="headerlink" title="8. 忽略文件"></a>8. 忽略文件</h2><p>应该忽略以下文件：</p><ul><li>系统或者软件自动生成的文件</li><li>编译产生的中间文件和结果文件</li><li>运行时生成日志文件、缓存文件、临时文件</li><li>涉及身份、密码、口令、密钥等敏感信息文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;日志文件&quot;</span> &gt; access.log</span><br><span class="line"><span class="built_in">echo</span> access.log &gt; .gitignore</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 .gitignore文件中加上 *.log 会忽略所有.log结尾的文件。</span></span><br><span class="line"><span class="comment">#在 .gitignore文件中加上 文件夹名称 会忽略文件夹中所有文件。</span></span><br><span class="line"><span class="comment">#已经添加到版本库中的文件不会被忽略。</span></span><br></pre></td></tr></table></figure><p><strong>.gitignore文件的匹配规则</strong></p><p>从上到下逐行匹配，每一行表示一个忽略模式</p><ul><li>空行或者以#开头的行会被Git忽略。一般空行用于可读性的分隔，#一般用作注释</li><li>使用标准的Blob模式匹配，例如：<ul><li>*通配任意个字符</li><li>?匹配单个字符</li><li>[]表示匹配列表中的单个字符，比如：[abc] 表示 a&#x2F;b&#x2F;c</li></ul></li><li>两个 ** 表示匹配任意的中间目录</li><li>中括号可以使用短中线连接，比如：[0-9]</li><li>!表示取反，忽略指令模式以外的文件或目录</li></ul><h2 id="9-SSH配置和克隆仓库"><a href="#9-SSH配置和克隆仓库" class="headerlink" title="9. SSH配置和克隆仓库"></a>9. SSH配置和克隆仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment">#生成SSH Key，私钥文件 : id_rsa 公钥文件 : id_rsa.pub</span></span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line"><span class="comment">#克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> repo-address</span><br><span class="line"><span class="comment">#推送更新内容</span></span><br><span class="line">git push &lt;remote&gt;&lt;branch&gt;</span><br><span class="line"><span class="comment">#拉取更新内容</span></span><br><span class="line">git pull &lt;remote&gt;</span><br></pre></td></tr></table></figure><h2 id="10-关联本地仓库和远程仓库"><a href="#10-关联本地仓库和远程仓库" class="headerlink" title="10. 关联本地仓库和远程仓库"></a>10. 关联本地仓库和远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加远程仓库:</span></span><br><span class="line">git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;<span class="comment">#step1</span></span><br><span class="line">git push -u &lt;远程仓库名&gt; &lt;分支名&gt;<span class="comment">#step2</span></span><br><span class="line"><span class="comment">#查看远程仓库:</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment">#拉取远程仓库内容:</span></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="11-Gitee的使用和GitLab本地化部署"><a href="#11-Gitee的使用和GitLab本地化部署" class="headerlink" title="11. Gitee的使用和GitLab本地化部署"></a>11. Gitee的使用和GitLab本地化部署</h2><p>Gitee：国内平台</p><p>GitLab：私有化部署</p><h2 id="12-分支简介和基本操作"><a href="#12-分支简介和基本操作" class="headerlink" title="12. 分支简介和基本操作"></a>12. 分支简介和基本操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看分支列表</span></span><br><span class="line">git b</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建新分支</span></span><br><span class="line">git branch &lt;新分支名&gt;</span><br><span class="line"><span class="comment">#切换分支 git checkout 也可以切换分支，但有歧义(恢复文件)</span></span><br><span class="line">git switch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并分支，将目标分支合并到当前分支</span></span><br><span class="line">git merge &lt;要合并的分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看分支图</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除已经完成合并的分支</span></span><br><span class="line">git branch -d &lt;分支名&gt;</span><br><span class="line"><span class="comment">#强制删除没有进行合并的分支</span></span><br><span class="line">git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode</title>
      <link href="/2023/09/28/VScode/"/>
      <url>/2023/09/28/VScode/</url>
      
        <content type="html"><![CDATA[<h2 id="VScode简介"><a href="#VScode简介" class="headerlink" title="VScode简介"></a>VScode简介</h2><p>Visual Studio Code（简称VS Code）是一个轻量级的源代码编辑器，由Microsoft开发。它支持多种编程语言和文件类型，并提供了丰富的功能和扩展性。</p><p>VS Code具有以下特点：</p><ol><li><p>跨平台支持：VS Code可在Windows、macOS和Linux等多个操作系统上运行，使开发者能够在不同的平台上保持一致的开发体验。</p></li><li><p>丰富的功能：VS Code提供了强大的编辑功能，包括语法高亮、智能代码补全、代码导航、代码片段、代码折叠、多光标编辑等。它还支持Git集成、调试器、终端、任务运行器等功能，使开发者能够在一个编辑器中完成大部分开发任务。</p></li><li><p>扩展性：VS Code支持丰富的扩展，开发者可以根据自己的需求选择和安装各种插件。这些插件可以提供额外的语言支持、工具集成、主题和界面定制等功能，使编辑器更加适应个人偏好和项目需求。</p></li><li><p>内置的集成终端：VS Code内置了终端，可以直接在编辑器中执行命令和运行脚本，无需切换到外部终端。</p></li><li><p>强大的调试功能：VS Code提供了调试器的支持，可以方便地进行代码调试和错误排查。它支持多种编程语言的调试，包括JavaScript、Python、C++等。</p></li></ol><p>总的来说，VS Code是一个功能强大、轻量级且可扩展的源代码编辑器。它提供了丰富的功能和插件，使开发者能够在一个编辑器中完成大部分开发任务。无论是进行日常的代码编辑、调试还是进行项目开发，VS Code都是一个非常受欢迎的选择。</p><h2 id="VScode连接Linux虚拟机"><a href="#VScode连接Linux虚拟机" class="headerlink" title="VScode连接Linux虚拟机"></a>VScode连接Linux虚拟机</h2><p>​使用VS Code连接Linux虚拟机进行开发的好处是，你可以在本地的编辑器中进行代码编写、调试和测试，无需在虚拟机中切换窗口或使用其他编辑器。这样可以提高开发效率，减少不必要的操作。同时，VS Code提供了丰富的编辑功能和扩展生态系统，可以帮助你更快地编写代码，减少出错的可能性。此外，VS Code还内置了终端支持和调试器，方便执行命令、运行脚本和进行代码调试。</p><p><strong>操作步骤</strong></p><p>使用VS Code连接Linux虚拟机可以按照以下步骤进行：</p><ul><li><p>配置虚拟机</p><ol><li><p>确保虚拟机的ssh服务可用</p><p>打开虚拟机，在终端命令行上敲入：sudo apt-get install openssh-server进行安装。</p><p>终端输入<code>systemctl status sshd</code>如果出现以下信息则表明虚拟机的ssh服务是打开的</p><img src="/2023/09/28/VScode/image-20230929214506470.png" class></li><li><p>使用<code>ifconfig</code>命令查看虚拟机IP地址</p></li></ol></li><li><p>配置VScode</p><ol><li>安装VS Code：从<a href="https://code.visualstudio.com/">VS Code官方网站</a>下载适用于你操作系统的安装包，并按照安装向导进行安装。</li><li>安装Remote Development扩展：打开VS Code编辑器后，在扩展商店中搜索并安装”Remote Development”扩展。这个扩展提供了连接远程服务器的功能。</li><li>配置SSH连接：在VS Code的侧边栏中点击扩展按钮（四个方块图标），找到”Remote-SSH”扩展。点击”Remote-SSH”扩展，选择”Connect to Host”，然后选择”Add New SSH Hosts…”（第一次成功后，之后再想连接直接选择虚拟机对应的IP地址就好了）。在弹出的输入框中按提示输入<code>ssh 用户名@虚拟机IP地址</code>（IP地址可以用虚拟机主机名代替）。输入完毕之后，点击确认下一步，选择保存SSH配置文件的路径，这里默认选择第一个就好。</li></ol></li></ul><p>通过以上步骤，你就可以使用VS Code连接Linux虚拟机进行开发了。</p><h2 id="VScode上传文件到Git"><a href="#VScode上传文件到Git" class="headerlink" title="VScode上传文件到Git"></a>VScode上传文件到Git</h2><p>VScode自带有支持Git的插件，用VScode打开一个Git仓库。之后点击Git图标，在这里就可以执行提交修改到暂存区、将暂存区文件上传本地仓库以及推送文件到Github等操作。</p><img src="/2023/09/28/VScode/image-20230929220753200.png" class><p>大部分git命令能完成的操作也都可以直接在这里执行。</p><img src="/2023/09/28/VScode/image-20230929220918200.png" class><p>更加详细的操作请读者查阅相关资料。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本</title>
      <link href="/2023/09/28/Shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/09/28/Shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p> Shell的作用是解释执行用户的命令，用户输入一条命令，Shell就解释执行一条，这种方式称为交互式（Interactive），Shell还有一种执行命令的方式称为批处理（Batch），用户事先写一个Shell脚本（Script），其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。Shell脚本是在Unix、Linux和类Unix系统中使用的一种脚本语言，用于编写一系列的命令和操作，以便在命令行中执行，消除重复的工作，其本质就是一系列shell命令的集合。Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，它为用户提供了一个面向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。<br>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。它可以执行一系列的命令、控制结构、变量和函数，以实现特定的任务，适用于系统管理、文件处理、数据处理、自动化测试等各种场景。</p><img src="/2023/09/28/Shell%E8%84%9A%E6%9C%AC/v2-497551e46d2b987313ddc456fb3a8f30_r.jpg" class><blockquote><p>Shell具体可描述为：外层应用程序是一些命令，是非机器语言，比如ls ， useradd等；而内核则识别的是机器语言0和1，让Shell解释器当一个“中介”，由非机器语言通过Shell解释器向机器语言的转化，转化后内核将命令传递给硬件执行。更直白的说，Shell就是我们操控的Linux终端界面，输入命令得到想要的功能。</p></blockquote><h2 id="Shell环境"><a href="#Shell环境" class="headerlink" title="Shell环境"></a>Shell环境</h2><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li><li>Bourne Again Shell（&#x2F;bin&#x2F;bash）</li><li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li><li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li><li>Shell for Root（&#x2F;sbin&#x2F;sh）</li><li>……</li></ul><p>我们主要关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><p><code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h2 id="创建和执行Shell脚本"><a href="#创建和执行Shell脚本" class="headerlink" title="创建和执行Shell脚本"></a>创建和执行Shell脚本</h2><p>创建一个.sh脚本文件，扩展名sh代表shell，扩展名并不影响程序运行，但最好见名知义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello word&quot;</span></span><br></pre></td></tr></table></figure><p><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>shell脚本的执行有两种方式：</p><ul><li><p>第一种方式：用bash解释器执行脚本文件，<code>bash 脚本文件名</code>，这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash test.sh</span><br><span class="line">/bin/sh test.sh</span><br><span class="line">bash test.sh</span><br><span class="line">sh test.sh</span><br></pre></td></tr></table></figure></li><li><p>第二种方式：用chmod给脚本文件添加可执行权限，使其变为可执行程序，再执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>解释器和编译器的区别：</p><p>解释器是一条一条的解释执行源语言。比如php，postscritp，javascript就是典型的解释性语言。它的优点是容易跨平台，同一套代码可以在几乎所有的操作系统上执行，而无需根据操作系统做修改；</p><p>编译器是把源代码整个编译成目标代码，它生成目标代码再由连接器生成可执行的机器码，执行时不再需要编译器，直接在支持目标代码的平台上运行，这样执行效率比解释执行快很多。缺点是需要根据不同的操作系统编制代码，虽然有像Qt这样的源代码级跨平台的编程工具库，但在不同的平台上仍然需要重新编译连接成可执行文件，但其执行效率要远远高于解释运行的程序。比如C语言代码被编译成二进制代码（exe程序），在windows平台上执行。</p></blockquote><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p><strong>变量的类型</strong></p><ul><li><p>自定义变量</p><ul><li>用户自己定义的变量</li><li>变量没有数据类型，默认为字符串类型</li><li>初始化的时候&#x3D;两边都不要留空</li><li>变量的调用需要加<code>$</code></li><li>当变量和其它字符串一起的时候，调用加<code>&#123;&#125;</code></li><li>不能直接变量&#x3D;变量，需要在右边的变量加<code>$</code></li><li>没有分号，以换行作为一个语句的结束</li></ul></li><li><p>位置变量</p><p>计算机把命令行参数的值传递给特定的变量从0开始调用，10以上的用{}括起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$&#123;10&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>预定义变量</p><p>计算机已经给一些特定的字符赋予了特殊的意义</p><p><code>$*</code>:所有的位置变量，但是不包括<code>$0</code><br><code>$@</code>:所有的位置变量，但是不包括<code>$0</code><br><code>$#</code>:位置变量的个数，但是不包括<code>$0</code><br><code>$?</code>:获得之前(上一个)进程(shell命令)结束的状态码 (0 表示成功, 1 表示失败)<br><code>$$</code>:获得当前进程 ID<br><code>$!</code>:获得之前(上一个)进程 ID</p></li><li><p>环境变量</p><ul><li>计算机已经赋值好的变量</li><li>env查看所有的环境变量</li><li>调用环境变量也需要加$</li></ul></li></ul><p>只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myName=<span class="string">&quot;HXY&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myName</span><br></pre></td></tr></table></figure><p>删除变量：使用 unset 命令可以删除变量（不能删除只读变量）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure><p><strong>变量运算</strong></p><ul><li><p><code>$(())</code></p><ul><li>能进行+-*&#x2F;%运算</li><li>能进行自加自减</li><li>能进行幂数运算</li><li>不能进行浮点型运算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=2</span><br><span class="line">b=3</span><br><span class="line">c=$((a**b))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$c</span></span><br></pre></td></tr></table></figure><blockquote><p>上面这个脚本使用<code>sh</code>解释器执行会报错，原因是<code>**</code>是 <code>bash</code> 运算符，在 <code>sh</code>里还没声明，所以报错。</p><p>注：<code>Debian</code>和<code>Ubuntu</code> 默认用<code>sh</code>作为<code>/bin/sh</code>的解释器</p></blockquote></li><li><p><code>$[]</code></p><ul><li>能进行+-*&#x2F;%运算</li><li>能进行自加自减</li><li>能进行幂数运算</li><li>不能进行浮点型运算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">b=34</span><br><span class="line">a=$[2**4]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure></li><li><p>expr</p><ul><li>需要用命令置换符&#96;&#96;置换出来结果</li><li>能进行<code>+-*/%</code>，但是在进行乘法运算的时候需要加<code>\*</code>和通配符<code>*</code>区分</li><li>不能进行幂数运算</li><li>不能进行浮点型运算</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">b=34</span><br><span class="line">a=`<span class="built_in">expr</span> 1 + 3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p><strong>shell字符串</strong></p><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号（有空格时一定要用引号）。</p><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。如果要在单引号里使用变量，需要将变量再用一对单引号包括起来。</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">&quot;HXY&quot;</span></span><br><span class="line">str=<span class="string">&#x27;My name is &#x27;</span><span class="variable">$my_name</span><span class="string">&#x27;!&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="variable">$str</span></span><br></pre></td></tr></table></figure><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li><li>双引号里可以直接使用单引号，不用转义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">&quot;HXY&quot;</span></span><br><span class="line">str=<span class="string">&quot;This&#x27;s my name <span class="variable">$my_name</span>!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="variable">$str</span></span><br></pre></td></tr></table></figure><p><strong>获取字符串长度</strong></p><p>实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span>    <span class="comment"># 输出 4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string[0]&#125;</span> <span class="comment"># 输出 4</span></span><br><span class="line"><span class="comment"># 变量为字符串时，$&#123;#string&#125; 等价于 $&#123;#string[0]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>提取子字符串</strong></p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;hxy is a cool boy&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:0:3&#125;</span> <span class="comment"># 从第0个元素开始提取3个字符</span></span><br></pre></td></tr></table></figure><p><strong>查找子字符串</strong></p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字符 m 或 n 的位置(哪个字母先出现就计算哪个)</span></span><br><span class="line">string=<span class="string">&quot;my name is hxy&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">expr</span> index <span class="string">&quot;<span class="variable">$string</span>&quot;</span> mn`<span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure><p>注意：这里输出的位置不是从0开始，而是从1开始。</p><h2 id="shell语句"><a href="#shell语句" class="headerlink" title="shell语句"></a>shell语句</h2><p><strong>解释性语句</strong></p><ul><li><p>注释一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br></pre></td></tr></table></figure></li><li><p>注释多行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上例子中，: 是一个空命令，用于执行后面的 Here 文档，&lt;&lt;&#x27;EOF&#x27; 表示开启 Here 文档，EOF 是 Here 文档的标识符，在这两个标识符之间的内容都会被视为注释，不会被执行。这个标识符可以随便取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line">: <span class="string">&#x27;</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="comment"># 我们也可以使用了冒号 : 命令，并用单引号 &#x27; 将多行内容括起来。由于冒号是一个空命令，这些内容不会被执行。冒号和单引号之间要用空格隔开</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>功能性语句</strong></p><ul><li><p>read</p><p>read命令用于从标准输入中读取输入单行，并将读取的单行根据IFS变量分裂成多个字段，并将分割后的字段分别赋值给指定的变量列表var_name。第一个字段分配给第一个变量var_name1，第二个字段分配给第二个变量var_name2，依次到结束。如果指定的变量名少于字段数量，则多出的字段数量也同样分配给最后一个var_name，如果指定的变量命令多于字段数量，则多出的变量赋值为空。如果没有指定任何var_name，则分割后的所有字段都存储在特定变量REPLY中。</p><p>选项说明：</p><ul><li>-a：将分裂后的字段依次存储到指定的数组中，存储的起始位置从数组的index&#x3D;0开始。</li><li>-d：指定读取行的结束符号。默认结束符号为换行符。</li><li>-n：限制读取N个字符就自动结束读取，如果没有读满N个字符就按下回车或遇到换行符，则也会结束读取。</li><li>-N：严格要求读满N个字符才自动结束读取，即使中途按下了回车或遇到了换行符也不结束。其中换行符或回车算一个字符。</li><li>-p：给出提示符。默认不支持”\n”换行，要换行需要特殊处理，见下文示例。例如，”-p 请输入密码：”</li><li>-r：禁止反斜线的转义功能。这意味着”&quot;会变成文本的一部分。</li><li>-s：静默模式。输入的内容不会回显在屏幕上。</li><li>-t：给出超时时间，在达到超时时间时，read退出并返回错误。也就是说不会读取任何内容，即使已经输入了一部分。</li><li>-u：从给定文件描述符(fd&#x3D;N)中读取数据。</li></ul></li><li><p>test</p><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><ul><li><p>数值测试</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">等于则为真</td></tr><tr><td align="center">-ne</td><td align="center">不等于则为真</td></tr><tr><td align="center">-gt</td><td align="center">大于则为真</td></tr><tr><td align="center">-ge</td><td align="center">大于等于则为真</td></tr><tr><td align="center">-lt</td><td align="center">小于则为真</td></tr><tr><td align="center">-le</td><td align="center">小于等于则为真</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数相等！&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个数不相等！&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>字符串测试</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">等于则为真</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不相等则为真</td></tr><tr><td align="center">-z</td><td align="center">字符串的长度为零则为真</td></tr><tr><td align="center">-n</td><td align="center">字符串的长度不为零则为真</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="string">&quot;ru1noob&quot;</span></span><br><span class="line">num2=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$num1</span> = <span class="variable">$num2</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个字符串相等!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个字符串不相等!&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>文件测试</p><p>文件类型判断</p><table><thead><tr><th align="center">选 项</th><th align="center">作 用</th></tr></thead><tbody><tr><td align="center">-b filename</td><td align="center">判断文件是否存在，并且是否为块设备文件。</td></tr><tr><td align="center">-c filename</td><td align="center">判断文件是否存在，并且是否为字符设备文件。</td></tr><tr><td align="center">-d filename</td><td align="center">判断文件是否存在，并且是否为目录文件。</td></tr><tr><td align="center">-e filename</td><td align="center">判断文件是否存在。</td></tr><tr><td align="center">-f filename</td><td align="center">判断文件是否存在，井且是否为普通文件。</td></tr><tr><td align="center">-L filename</td><td align="center">判断文件是否存在，并且是否为符号链接文件。</td></tr><tr><td align="center">-p filename</td><td align="center">判断文件是否存在，并且是否为管道文件。</td></tr><tr><td align="center">-s filename</td><td align="center">判断文件是否存在，并且是否为非空。</td></tr><tr><td align="center">-S filename</td><td align="center">判断该文件是否存在，并且是否为套接字文件。</td></tr></tbody></table><p>文件权限判断</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">-r filename</td><td align="center">判断文件是否存在，并且是否拥有读权限。</td></tr><tr><td align="center">-w filename</td><td align="center">判断文件是否存在，并且是否拥有写权限。</td></tr><tr><td align="center">-x filename</td><td align="center">判断文件是否存在，并且是否拥有执行权限。</td></tr><tr><td align="center">-u filename</td><td align="center">判断文件是否存在，并且是否拥有 SUID 权限。</td></tr><tr><td align="center">-g filename</td><td align="center">判断文件是否存在，并且是否拥有 SGID 权限。</td></tr><tr><td align="center">-k filename</td><td align="center">判断该文件是否存在，并且是否拥有 SBIT 权限。</td></tr></tbody></table><p>文件比较</p><table><thead><tr><th align="center">参 数</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">filename1 -nt filename2</td><td align="center">判断 filename1 的修改时间是否比 filename2 的新。</td></tr><tr><td align="center">filename -ot filename2</td><td align="center">判断 filename1 的修改时间是否比 filename2 的旧。</td></tr><tr><td align="center">filename1 -ef filename2</td><td align="center">判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td></tr></tbody></table><p>Shell 提供了与<code>-a</code>、或<code>-o</code>、非<code>!</code>三个逻辑操作符用于将测试条件连接起来，其优先级为： <code>!</code> 最高， <code>-a</code> 次之， <code>-o</code> 最低。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./sh -a -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个shell脚本解释器都有&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;有一个没有或者两个shell脚本解释器都没有&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>[]</code>可以代替test做判断的功能，在使用的时候需要左右两边都空开，</p><p><code>(())</code>及<code>[[]]</code> :它们分别是<code>[]</code>的针对数学比较表达式和字符串表达式的加强版。其中<code>(())</code>，不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号：</p><img src="/2023/09/28/Shell%E8%84%9A%E6%9C%AC/v2-4585b7d2ef9300917868e52783961957_r.jpg" class><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> [ -e ./sh -a -e ./bash ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个shell脚本解释器都有&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;有一个没有或者两个shell脚本解释器都没有&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>控制语句</strong></p><ul><li><p>条件控制语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if else</span></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if else-if else</span></span><br><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> == <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 等于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &gt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 大于 b&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$a</span> &lt; <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;a 小于 b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;没有符合的条件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>选择语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于其他语言里的switch</span></span><br><span class="line"><span class="keyword">case</span> value <span class="keyword">in</span></span><br><span class="line">mode1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">mode2)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入你的成绩&#x27;</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    6?)  <span class="built_in">echo</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    7?)  <span class="built_in">echo</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    8?)  <span class="built_in">echo</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    9?)  <span class="built_in">echo</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    100) <span class="built_in">echo</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">&#x27;E&#x27;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><ul><li><p>for循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种用法和c语言类似</span></span><br><span class="line"><span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第二种用法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 单词表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种用法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> &#123;n..m&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四种用法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> `<span class="built_in">command</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">for</span> (( ; ; ))</span><br></pre></td></tr></table></figure></li><li><p>while循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本用法</span></span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var=1</span><br><span class="line"><span class="keyword">while</span>((var &lt; <span class="number">10</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">((var++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>until 循环</p><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p><p>until 语法格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> [ ! <span class="variable">$a</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   a=`<span class="built_in">expr</span> <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>跳出循环</p><p>与C语言一样，shell脚本也可以用<code>break</code>结束循环，或者<code>continue</code>结束本次循环进行下一次循环。</p></li></ul></li></ul><h2 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h2><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。与大部分编程语言类似，数组元素的下标由 0 开始。</p><p>Shell 数组用括号来表示，元素用”空格”符号分割开，如果一个元素想赋值多个用空格隔开的字符串，需要将这些字符串用双引号 <code>&quot;&quot;</code> 包裹起来，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 value2 ... valuen)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">arr=(A B <span class="string">&quot;hello world&quot;</span> D)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line">arr[0]=A</span><br><span class="line">arr[1]=B</span><br><span class="line">arr[2]=<span class="string">&quot;hello world&quot;</span></span><br><span class="line">arr[3]=D</span><br></pre></td></tr></table></figure><p><strong>关联数组</strong></p><p>Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。</p><p>关联数组使用 <code>declare</code> 命令来声明，语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A array_name</span><br></pre></td></tr></table></figure><p><code>-A</code> 选项就是用于声明一个关联数组。关联数组的键是唯一的。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A arr=([<span class="string">&quot;google&quot;</span>]=<span class="string">&quot;www.google.com&quot;</span> [<span class="string">&quot;runoob&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span> [<span class="string">&quot;taobao&quot;</span>]=<span class="string">&quot;www.taobao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以先声明再定义</span></span><br><span class="line"><span class="built_in">declare</span> -A site</span><br><span class="line">site[<span class="string">&quot;google&quot;</span>]=<span class="string">&quot;www.google.com&quot;</span></span><br><span class="line">site[<span class="string">&quot;runoob&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">site[<span class="string">&quot;taobao&quot;</span>]=<span class="string">&quot;www.taobao.com&quot;</span></span><br></pre></td></tr></table></figure><p><strong>读取数组元素</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>遍历数组元素</strong></p><p>使用 <code>@</code> 或 <code>*</code> 可以获取数组中的所有元素。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[0]=A</span><br><span class="line">arr[1]=B</span><br><span class="line">arr[2]=C</span><br><span class="line">arr[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的元素为: <span class="variable">$&#123;arr[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的元素为: <span class="variable">$&#123;arr[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>获取数组的键</strong></p><p>在数组前加一个感叹号 <code>!</code> 可以获取数组的所有键。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A arr=([<span class="string">&quot;google&quot;</span>]=<span class="string">&quot;www.google.com&quot;</span> [<span class="string">&quot;runoob&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span> [<span class="string">&quot;taobao&quot;</span>]=<span class="string">&quot;www.taobao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的键为: <span class="variable">$&#123;!arr[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组的键为: <span class="variable">$&#123;!arr[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>获取数组的长度</strong></p><p>获取数组长度的方法与获取字符串长度的方法相同。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[0]=A</span><br><span class="line">arr[1]=B</span><br><span class="line">arr[2]=C</span><br><span class="line">arr[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组元素个数为: <span class="variable">$&#123;#arr[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;数组元素个数为: <span class="variable">$&#123;#arr[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>没有数据类型，没有形参，但是可以传参。函数里面定义的变量都是全局变量，但是变量在函数调用之后才会生效，定义局部变量local。<br>一般形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func_name()<span class="comment"># function关键字可以没有</span></span><br><span class="line">&#123;</span><br><span class="line">   func_body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的调用：函数名</li><li>函数返回值：可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）。函数返回值在调用该函数后通过 <code>$?</code> 来获得（0~255，超过就从0开始循环）。需要注意的是，<code>$?</code> 的值是上一条命令的返回状态，如果函数调用后不是立即用 <code>$?</code> 接收函数的返回值，而是插入了别的命令，那么 <code>$?</code> 接收到的返回值就不是函数的返回值了。</li><li>函数的传参：<code>函数名 实参1 实参2 实参3...</code>参数之间用空格隔开，在函数里面从<code>$1</code>开始接收传参</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span> <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span><span class="comment"># 2 </span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span><span class="comment"># 10</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span>     <span class="comment"># 11</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 256</span><br><span class="line">&#125;</span><br><span class="line">func 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">return</span> is $? <span class="comment"># 这里的 $? 是0，因为返回值是256超过了255，重新从0开始</span></span><br></pre></td></tr></table></figure><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make</title>
      <link href="/2023/09/28/Make/"/>
      <url>/2023/09/28/Make/</url>
      
        <content type="html"><![CDATA[<h2 id="Make介绍"><a href="#Make介绍" class="headerlink" title="Make介绍"></a>Make介绍</h2><p>使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Visual C++的nmake，QtCreator的qmake等。</p><p>make工具在构造项目的时候需要加载一个叫做makefile的文件，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>makefile文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。</p><p>Make命令执行时，默认情况下make 会在当前目录下按顺序找寻名字为：GNUmakefile、makefile、Makefile 中的一个解释文件（建议用Makefile）。如果要指定makefile 可以加上-f参数，如下所示</p><blockquote><p>make -f makefile_filename</p></blockquote><h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>makefile每条规则的语法格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target1,target2...: depend1, depend2, ...</span><br><span class="line">command</span><br></pre></td></tr></table></figure><p>每条规则由三个部分组成分别是目标(target), 依赖(depend)和命令(command)。</p><ul><li><p>目标(target)： 规则中的目标，这个目标和规则中的命令是对应的</p><ul><li><p>通过执行规则中的命令，可以生成一个和目标同名的文件</p></li><li><p>规则中可以有多个命令, 因此可以通过这多条命令来生成多个目标, 所有目标也可以有很多个</p></li><li><p>通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为伪目标</p></li></ul></li><li><p>依赖(depend): 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。</p><ul><li>例如：生成可执行文件的目标文件（*.o）可以作为依赖使用</li><li>如果规则的命令中不需要任何依赖，那么规则的依赖可以为空</li><li>当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套</li><li>依赖可以根据要执行的命令的实际需求, 指定很多个</li></ul></li><li><p>命令(command): 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令</p><ul><li>例如：通过某个命令编译文件、生成库文件、进入目录等。</li><li>动作可以是多个，每个命令前必须有一个Tab缩进并且独占占一行。</li></ul></li></ul><h2 id="Make工作原理"><a href="#Make工作原理" class="headerlink" title="Make工作原理"></a>Make工作原理</h2><blockquote><p>在此主要为大家剖析一下通过提供的 makefile 文件，构建工具 make 什么时候编译项目中的所有文件, 什么时候只选择更新项目中的某几个文件。另外再研究一下如果makefile里边有多个规则它们之间是如何配合工作的。</p></blockquote><h3 id="规则的执行"><a href="#规则的执行" class="headerlink" title="规则的执行"></a>规则的执行</h3><p>​在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但是需要注意的是，好多时候要执行的动作（命令）中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p><p>​对应的解决方案是先将需要的依赖生成出来，我们就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p><p>​这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有test.o这个依赖，make会向下寻找是否有规则产生了这个依赖</span></span><br><span class="line"><span class="section">test:test.o</span></span><br><span class="line">gcc test.o -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure><p><strong>执行指定规则：</strong></p><p>​如果想要执行 makefile 中非第一条规则对应的命令, 那么就不能直接 make, 需要将那条规则的目标也写到make的后边, 比如只需要执行生成test.o的命令, 就需要: make test.o。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如删除中间文件、程序的打包、程序的备份等等，然后把这些命令放在一个伪目标后，这样就可以通过<code>make 伪目标名</code>来执行这些命令了。</p><h3 id="文件的时间戳"><a href="#文件的时间戳" class="headerlink" title="文件的时间戳"></a>文件的时间戳</h3><p>make 命令执行的时候会根据文件的时间戳判定是否执行makefile文件中相关规则中的命令。</p><p>​目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳, 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件, 那么规则中的命令就不会被执行。<br>当依赖文件被更新了, 文件时间戳也会随之被更新, 这时候 目标时间戳 &lt; 某些依赖的时间戳, 在这种情况下目标文件会通过规则中的命令被重新生成。<br>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</p><h3 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h3><p>make 是一个功能强大的构建工具，虽然make需要根据 makefile 中指定的规则来完成源文件的编译。作为小白的我们编写makefile的时候难免写的不是那么严谨从而漏写一些构建规则，但是我们会发现程序还是会被编译成功。这是因为 make 有自动推导的能力，不会完全依赖 makefile。</p><p>比如: 使用命令 make 编译扩展名为.c 的 C 语言文件的时候，源文件的编译规则不用明确给出。这是因为 make 进行编译的时候会使用一个默认的编译规则，按照默认规则完成对.c文件的编译，生成对应的.o 文件。它使用命令<code>cc -c</code>来编译.c 源文件。在 Makefile 中只要给出需要构建的目标文件名（一个.o 文件），make 会自动为这个.o 文件寻找合适的依赖文件（对应的.c 文件），并且使用默认的命令来构建这个目标文件。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile中的变量分为三种：自定义变量，预定义变量和自动变量。</p><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。需要注意的是，创建变量后必须为其赋值。</p><p><strong>变量赋值</strong></p><ul><li><p>普通赋值，在给b变量赋a变量时，b变量会先被赋a变量的当前值，之后b变量会随a变量的改变而改变</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=$a</span><br><span class="line">a=20</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#20</span></span><br><span class="line">@echo $b<span class="comment">#20</span></span><br></pre></td></tr></table></figure></li><li><p>立即赋值，在给b变量赋a变量时，b变量会先被赋a变量的当前值，之后b变量不会随a变量的改变而改变</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b:=$a</span><br><span class="line">a=20</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#20</span></span><br><span class="line">@echo $b<span class="comment">#10</span></span><br></pre></td></tr></table></figure></li><li><p>询问赋值，在给b变量赋值时，会查看b变量在前面是否有赋值，如果有，此时赋值无效</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b:=$a</span><br><span class="line">b?=20</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#10</span></span><br><span class="line">@echo $b<span class="comment">#10</span></span><br></pre></td></tr></table></figure></li><li><p>追加赋值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b:=$a</span><br><span class="line">a+=hxy is cool boy</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $a<span class="comment">#10 hxy is cool b</span></span><br><span class="line">@echo $b<span class="comment">#10</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建变量obj target</span></span><br><span class="line">obj=main.o  mult.o  sub.o</span><br><span class="line">target=test</span><br><span class="line"><span class="comment"># 取出变量用$(变量名)</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：</p><table><thead><tr><th align="center">变 量 名</th><th align="center">含 义</th><th align="center">默 认 值</th></tr></thead><tbody><tr><td align="center">AR</td><td align="center">生成静态库库文件的程序名称</td><td align="center">ar</td></tr><tr><td align="center">AS</td><td align="center">汇编编译器的名称</td><td align="center">as</td></tr><tr><td align="center">CC</td><td align="center">C 语言编译器的名称</td><td align="center">cc</td></tr><tr><td align="center">CPP</td><td align="center">C 语言预编译器的名称</td><td align="center">$(CC) -E</td></tr><tr><td align="center">CXX</td><td align="center">C++语言编译器的名称</td><td align="center">g++</td></tr><tr><td align="center">FC</td><td align="center">FORTRAN 语言编译器的名称</td><td align="center">f77</td></tr><tr><td align="center">RM</td><td align="center">删除文件程序的名称</td><td align="center">rm -f</td></tr><tr><td align="center">ARFLAGS</td><td align="center">生成静态库库文件程序的选项</td><td align="center">无默认值</td></tr><tr><td align="center">ASFLAGS</td><td align="center">汇编语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CFLAGS</td><td align="center">C 语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CPPFLAGS</td><td align="center">C 语言预编译的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CXXFLAGS</td><td align="center">C++语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">FFLAGS</td><td align="center">FORTRAN 语言编译器的编译选项</td><td align="center">无默认值</td></tr></tbody></table><p><strong>GCC编译选项CFLAGS参数</strong></p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">用于把源码文件编译成 .o 对象文件,不进行链接过程</td></tr><tr><td align="center">-o</td><td align="center">用于连接生成可执行文件，在其后可以指定输出文件的名称</td></tr><tr><td align="center">-g</td><td align="center">用于在生成的目标可执行文件中，添加调试信息，可以使用GDB进行调试</td></tr><tr><td align="center">-Idir</td><td align="center">用于把新目录添加到include路径上，可以使用相对和绝对路径，“-I.”、“-I.&#x2F;include”、“-I&#x2F;opt&#x2F;include”</td></tr><tr><td align="center">-Wall</td><td align="center">生成常见的所有告警信息，且停止编译，具体是哪些告警信息，请参见GCC手册，一般用这个足矣！</td></tr><tr><td align="center">-w</td><td align="center">关闭所有告警信息</td></tr><tr><td align="center">-O</td><td align="center">表示编译优化选项，其后可跟优化等级0\1\2\3，默认是0，不优化</td></tr><tr><td align="center">-fPIC</td><td align="center">用于生成位置无关的代码</td></tr><tr><td align="center">-v</td><td align="center">(在标准错误stderr)显示执行编译阶段的命令，同时显示编译器驱动程序,预处理器,编译器的版本号</td></tr></tbody></table><p><strong>GCC链接选项LDFLAGS参数</strong></p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-llibrary</td><td align="center">链接时在标准搜索目录中寻找库文件，搜索名为liblibrary.a 或 liblibrary.so</td></tr><tr><td align="center">-Ldir</td><td align="center">用于把新目录添加到库搜索路径上，可以使用相对和绝对路径，“-L.”、“-L.&#x2F;include”、“-L&#x2F;opt&#x2F;include”</td></tr><tr><td align="center">-Wl,option</td><td align="center">把选项 option 传递给连接器，如果 option 中含有逗号,就在逗号处分割成多个选项</td></tr><tr><td align="center">-static</td><td align="center">使用静态库链接生成目标文件，避免使用共享库，生成目标文件会比使用动态链接库大</td></tr></tbody></table><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。下表中是一些常见的自动变量：</p><table><thead><tr><th align="center">变量</th><th align="center">含 义</th></tr></thead><tbody><tr><td align="center">$*</td><td align="center">表示目标文件的名称，不包含目标文件的扩展名</td></tr><tr><td align="center">$+</td><td align="center">表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能包含重复的依赖文件</td></tr><tr><td align="center">$&lt;</td><td align="center">表示依赖项中第一个依赖文件的名称</td></tr><tr><td align="center">$?</td><td align="center">依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td></tr><tr><td align="center">$@</td><td align="center">表示目标文件的名称，包含文件扩展名</td></tr><tr><td align="center">$^</td><td align="center">依赖项中，所有不重复的依赖文件，这些文件之间以空格分开</td></tr></tbody></table><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名</span></span><br><span class="line"><span class="comment"># 下面这条规则会不断执行，直到所有.c文件都被编译为.o文件，%对应的文件名时刻在变化，所以需要用自动变量$&lt;</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc <span class="variable">$&lt;</span> -c</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>makefile中有很多函数并且所有的函数都是有返回值的。makefile中函数的写法是这样的：<code> $(函数名 参数1, 参数2, 参数3, ...)</code>，主要目的是让我们能够快速方便的得到函数的返回值。</p><p>这里为大家介绍两个 makefile 中使用频率比较高的函数：wildcard和patsubst。</p><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><p>这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔</span></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br><span class="line">参数:指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c</span><br></pre></td></tr></table></figure><ul><li>参数功能:<ul><li>PATTERN 指的是某个或多个目录下的对应的某种类型的文件, 比如当前目录下的.c文件可以写成 *.c<br>可以指定多个目录，每个路径之间使用空格间隔。</li></ul></li><li>返回值：<ul><li>得到的若干个文件的文件列表， 文件名之间使用空格间隔<br>示例：<code>$(wildcard *.c ./sub/*.c)</code><br>返回值格式：<code>a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c</code></li></ul></li></ul><p><strong>函数使用举例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/hxy/a/*.c /home/hxy/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure><h3 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h3><p>这个函数的功能是按照指定的模式替换指定的文件名的后缀, 函数原型如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有三个参数, 参数之间使用 逗号间隔</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p>参数功能:</p><ul><li><p>pattern: 这是一个模式字符串, 需要指定出要被替换的文件名中的后缀是什么</p><ul><li>文件名和路径不需要关心, 因此使用 % 表示即可 [通配符是 %]</li><li>在通配符后边指定出要被替换的后缀, 比如: %.c, 意味着 .c的后缀要被替换掉</li></ul></li><li><p>replacement: 这是一个模式字符串, 指定参数pattern中的后缀最终要被替换为什么</p><ul><li>还是使用 % 来表示参数pattern 中文件的路径和名字</li><li>在通配符 % 后边指定出新的后缀名, 比如: %.o 这表示原来的后缀被替换为 .o</li></ul></li><li><p>text: 该参数中存储这要被替换的原始数据</p></li></ul></li><li><p>返回值:</p><ul><li>函数返回被替换过后的字符串。</li></ul></li></ul><p><strong>函数使用举例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure><h2 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h2><p>以下是一个makefile示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-Wall -O2 -g -std=gnu99 -pthread -I./inc</span><br><span class="line">LDFALGS= -L./lib -lseqlist</span><br><span class="line">CC=gcc</span><br><span class="line">APP=test</span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(APP)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$(APP)</span> <span class="variable">$^</span> <span class="variable">$(CFALGS)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$(APP)</span> <span class="variable">$(CFALGS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean # 声明clean是个伪目标，即使当前目录有clean也不会受影响</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o run</span><br></pre></td></tr></table></figure><p><strong>伪目标：</strong></p><p>​以<code>make clean</code>为例，因为我们并不生成 clean 这个文件。所以伪目标只是一个标签，由于伪目标不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个目标才能让其生效。当然，伪目标的取名不能和文件名重名，不然其就失去了伪目标的意义了。因此，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记<code>.PHONY</code>来显示地指明一个目标是伪目标，向make说明，不管是否有这个文件，这个目标就是伪目标。<code>.PHONY : clean</code>只要有这个声明，不管是否有<code>clean</code>文件，要运行<code>clean</code>这个目标，只有<code>make clean</code>这样。伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为默认目标，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:app1 app2</span></span><br><span class="line"><span class="section">app1:test1.c</span></span><br><span class="line">gcc test1.c -o app1</span><br><span class="line"><span class="section">app2:test2.c</span></span><br><span class="line">gcc test2.c -o app2</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm app1 app2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/2023/09/28/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/09/28/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>下面是 Linux 常用命令的简单介绍。但实际上，Linux 命令的种类和功能还有很多，每个命令都有许多参数和选项，在这就不一一介绍，需要的朋友可以自行网上查找相关资料。</p><p><strong>文件和目录操作命令</strong></p><ul><li>ls：列出当前目录中的文件和子目录。</li><li>cd：切换当前工作目录。</li><li>mkdir：创建一个新的目录。</li><li>rmdir：删除一个空目录。</li><li>touch：创建一个新文件，或者更新已有文件的时间戳。</li><li>cp：复制文件或目录。</li><li>mv：移动或重命名文件或目录。</li><li>rm：删除文件或目录。</li><li>chmod：修改文件或目录的访问权限。</li><li>chown：修改文件或目录的所有者。</li><li>chgrp：修改文件或目录的所属群组。</li></ul><p><strong>文件查看和编辑命令</strong></p><ul><li><p>cat：从头开始显示文件内容。</p></li><li><p>more：逐屏显示文件内容，用空格键翻页，按 Q 键退出。</p></li><li><p>less：类似于 more 命令，但比 more 更强大，提供了快速搜索和定位等功能。</p></li><li><p>tail：显示文件的最后几行。</p></li><li><p>head：显示文件的头几行。</p></li><li><p>vim：一个常用的文本编辑器，支持命令模式、插入模式和可视模式等多种编辑方式。</p></li></ul><p><strong>系统管理命令</strong></p><ul><li>ps：查看当前运行进程的情况。</li><li>top：展示系统当前运行的进程、资源占用情况等信息。</li><li>kill：向指定进程发送信号，以停止、暂停或重新启动该进程。</li><li>df：查看磁盘空间使用情况。</li><li>du：查看目录中文件大小的统计信息。</li><li>ping：检测网络连接是否正常，测试主机与目的计算机之间的响应时间。</li><li>ifconfig：配置网络接口的 IP 地址、掩码等参数。</li><li>netstat：展示网络连接、路由表、网络接口等信息。</li><li>ssh：安全地登录远程主机并执行命令。</li><li>sudo：以超级用户身份执行命令。</li><li>tar：对文件和目录进行压缩和解压缩操作。</li><li>scp：使用 SSH 协议，将文件从本地复制到远程主机或将远程主机上的文件复制到本地。</li></ul><p><strong>curl 命令</strong></p><p>用于使用 URL 获得文件并将其输出到标准输出。常用参数如下：</p><ul><li>curl -O <a href="https://example.com/file.txt%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6">https://example.com/file.txt：将文件</a> <a href="https://example.com/file.txt">https://example.com/file.txt</a> 下载到当前目录。</li></ul><p><strong>wget 命令</strong></p><p>也用于下载文件。常用参数如下：</p><ul><li>wget <a href="https://example.com/file.txt%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6">https://example.com/file.txt：将文件</a> <a href="https://example.com/file.txt">https://example.com/file.txt</a> 下载到当前目录。</li></ul><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>离线下载<br>下载：<code>sudo dpkg -i软件包名</code>：下载软件包<br>卸载：<code>sudo dpkg -r软件名</code>：卸载<br>优势：不用去找依赖文件，下载速度快</p><p>在线下载<br>下载：<code>sudo apt-get install 软件名</code><br>卸载：<code>sudo apt-get remove 软件名</code><br>需要联网，也需要找依赖文件，下载较慢</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li><p>通配符：</p><ul><li><p><code>*</code>：通配所有字符</p></li><li><p><code>&#123;n..m&#125;</code>:通配连续的n到m之间的字符，包括本身</p></li><li><p><code>[]</code>：通配一个字符</p></li><li><p><code>[12345abc]</code>：通配里面存在的字符</p></li><li><p><code>[1-5]</code>：通配连续的字符</p></li><li><p><code>[^a]</code>:通配除5以外的字符</p></li><li><p><code>?</code>：通配一个字符</p></li></ul></li><li><p>输入输出重定向：</p><ul><li><code>&gt;</code>   :覆盖赋值</li><li><code>&gt;&gt;</code>：追加赋值</li></ul></li><li><p>管道|：<code>命令1 | 命令2</code>把命令1的输出作为命令2的输入</p></li><li><pre><code class="tex">命令置换符``命令1 `命令2`:把命令2的输出作为命令1的参数</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC</title>
      <link href="/2023/09/27/GCC/"/>
      <url>/2023/09/27/GCC/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h2><p>​GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Objective-C、Fortran、Ada、GoFortran 和 Java 以及各类处理器架构上的汇编语言，GCC还包括了这些语言的库（如libstdc++，libgcj等。）。 因此，GCC也被重新定义为“GNU Compiler Collection”，成为历史上最优秀的编译器套件， 其执行效率与一般的编译器相比平均效率要高 20%~30%。</p><p>​GCC由一系列的编译器和工具集（例如ar、nm等）组成，每个编译器都用于处理特定的编程语言。其中最常用的是GCC的C编译器（gcc）和C++编译器（g++）。这两个编译器可以将C和C++源代码编译成可执行文件或库文件。</p><p>​GCC提供了丰富的编译选项和优化功能，可以根据需要进行配置和调整。它支持多种目标平台和操作系统，包括Linux、Windows、macOS等。GCC还支持多种架构和处理器，如x86、ARM、MIPS等。</p><h2 id="GCC编译工具链"><a href="#GCC编译工具链" class="headerlink" title="GCC编译工具链"></a>GCC编译工具链</h2><p>GCC编译工具链（toolchain），是指以GCC编译器为核心的一整套工具。它主要包含以下三部分内容：</p><ul><li>gcc-core：即GCC编译器，用于完成预处理和编译过程，把C代码转换成汇编代码。</li><li>Binutils ：除GCC编译器外的一系列小工具包括了链接器ld，汇编器as、目标文件格式查看器readelf等。</li><li>glibc：包含了主要的 C语言标准函数库，C语言中常常使用的打印函数printf、malloc函数就在glibc 库中。</li></ul><p>在很多场合下会直接用GCC编译器来指代整套GCC编译工具链。</p><h2 id="gcc基本用法"><a href="#gcc基本用法" class="headerlink" title="gcc基本用法"></a>gcc基本用法</h2><p>GCC最基本的用法是∶gcc [options] [filenames]</p><p>其中options就是编译器所需要的参数，filenames给出相关的文件名称。下面是一些常用gcc参数：</p><ul><li>-c，只编译，不链接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常用于编译不包含主程序的子程序文件。</li><li>-o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出预设的可执行文件a.out。</li><li>-g，产生符号调试工具（GNU的gdb）所必要的符号资讯，要想对源代码进行调试，我们就必须加入这个选项。</li><li>-O，对程序进行优化编译、链接，采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、链接的速度就相应地要慢一些。</li><li>-O2，比-O更好的优化编译、链接，当然整个编译、链接过程会更慢。</li><li>-Idirname，将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。C程序中的头文件包含两种情况∶<ul><li>#include &lt;&gt; ：专门用来包含系统提供的头文件（由操作系统自带的，不是程序员自己写的）。编译器只会到系统指定目录去寻找这个头文件，也可以用-I附加指定其他的包含路径。</li><li>#include “”  ：用来包含自己写的头文件，编译器默认先在当前目录下寻找相应的头文件，如果没找到再到系统指定的目录去寻找，也可以用-I附加指定其他的包含路径。</li></ul></li><li>-v gcc执行时执行的详细过程，gcc及其相关程序的版本号</li></ul><h2 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h2><p>​对于C语言程序，我们需要将它编译链接为可执行的二进制文件，然后由系统加载执行。在Linux系统中，GCC编译程序会读取源代码文件，并且将其翻译成一个可执行文件，整个过程共四个阶段，由编译工具链完成。下面将详细介绍这四个过程。</p><h3 id="预处理（cpp）"><a href="#预处理（cpp）" class="headerlink" title="预处理（cpp）"></a>预处理（cpp）</h3><p>在命令行下输入<code>gcc -E test.c -o test.i</code>，预处理器会对以#开头的预处理命令进行处理，如读取头文件、宏替换等。在这之后会得到一个新的C程序，我们一般将其命名为.i文件。</p><p>编译器本身的主要目的是编译源代码，将C语言的源代码转化成.s的汇编代码。编译器聚焦核心功能后，剥离出的一部分非核心功能由预处理器执行。预处理器对源代码进行一些预先处理，为后续编译打好基础后，再由编译器编译。</p><p>预处理器涉及的内容：</p><ul><li>文件包含</li><li>宏定义</li><li>条件编译</li><li>一些特殊的预处理关键字</li><li>去掉程序中的注释</li></ul><p><strong>test.i如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title function_">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span>;</span><br><span class="line"># <span class="number">858</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __uflow (FILE *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br><span class="line"># <span class="number">873</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译（cc）"><a href="#编译（cc）" class="headerlink" title="编译（cc）"></a>编译（cc）</h3><p>在命令行下输入<code>gcc -S test.i -o test.s</code>，当然也可以是<code>gcc -S test.c -o test.s</code>，只是这种方式是由预处理器和编译器一起完成的，编译器将test.i翻译成了test.s汇编文件，汇编程序是一条条通用的机器语言指令。</p><p><strong>test.s如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;test.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;test&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">endbr64</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">leaq.LC0(%rip), %rdi</span><br><span class="line">callputs@PLT</span><br><span class="line">movl$0, %eax</span><br><span class="line">popq%rbp</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">.section.note.gnu.property,&quot;a&quot;</span><br><span class="line">.align 8</span><br><span class="line">.long 1f - 0f</span><br><span class="line">.long 4f - 1f</span><br><span class="line">.long 5</span><br><span class="line">0:</span><br><span class="line">.string &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">.align 8</span><br><span class="line">.long 0xc0000002</span><br><span class="line">.long 3f - 2f</span><br><span class="line">2:</span><br><span class="line">.long 0x3</span><br><span class="line">3:</span><br><span class="line">.align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure><h3 id="汇编（as）"><a href="#汇编（as）" class="headerlink" title="汇编（as）"></a>汇编（as）</h3><p>在命令行下输入<code>gcc -c test.s -o test.o</code>，汇编器会将test.s翻译成机器语言指令，将这些指令打包为***.o格式的可重定位文件，并将结果保存在目标文件test.o中。目标文件是由不同的段组成，通常一个目标至少有两个段：数据段和代码段。hello.o用文本文档打开后是无法看懂的，因为这是二进制文件。</p><h3 id="链接（ld）"><a href="#链接（ld）" class="headerlink" title="链接（ld）"></a>链接（ld）</h3><p>在命令行下输入<code>gcc test.o -o test</code>，链接器会将test.o和其他库文件、目标代码链接后形成可执行文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2023/09/27/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/27/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>​策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据需要选择算法的行为。它通过将算法封装在独立的策略类中，并让客户端根据需要选择不同的策略类来实现不同的行为。</p><p>​策略模式的主要目的是将算法的定义与使用分离，使得算法的变化不会影响到使用算法的客户端。它通过定义一个公共的接口或基类来表示所有的策略类，然后每个具体的策略类都实现该接口或继承该基类，并提供自己的算法实现。</p><p>下面是一个使用策略模式的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy1</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing strategy 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy2</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing strategy 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : <span class="built_in">strategy</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体策略对象</span></span><br><span class="line">    ConcreteStrategy1 strategy1;</span><br><span class="line">    ConcreteStrategy2 strategy2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建上下文对象，并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(&amp;strategy1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    context.<span class="built_in">executeStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(&amp;strategy2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行新的策略</span></span><br><span class="line">    context.<span class="built_in">executeStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个策略接口（Strategy），其中包含了一个纯虚函数execute()，用于执行具体的算法。</p><p>然后，我们创建了两个具体的策略类（ConcreteStrategy1和ConcreteStrategy2），它们分别实现了Strategy接口，并提供了自己的算法实现。</p><p>接下来，我们定义了一个上下文类（Context），它包含了一个指向Strategy对象的指针，并提供了设置策略和执行策略的方法。</p><p>在main函数中，我们先创建了具体的策略对象strategy1和strategy2，然后创建了上下文对象context，并将初始策略设置为strategy1。接着，我们调用context的executeStrategy()方法来执行策略。</p><p>然后，我们通过调用context的setStrategy()方法将策略切换为strategy2，并再次调用executeStrategy()方法来执行新的策略。</p><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executing strategy 1</span><br><span class="line">Executing strategy 2</span><br></pre></td></tr></table></figure><p>这个示例展示了策略模式的基本用法，它允许在运行时动态地选择不同的策略来实现不同的行为。这种灵活性使得策略模式在需要根据不同的条件选择算法时特别有用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2023/09/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>​代理模式（Proxy Pattern）是一种结构型设计模式，它允许通过创建一个代理对象来控制对另一个对象的访问。代理对象充当了另一个对象的接口，以便可以通过代理对象来访问另一个对象，同时可以在访问另一个对象之前或之后执行一些额外的操作。</p><p>​代理模式的主要目的是提供一种间接访问另一个对象的方式，以便可以在访问对象之前或之后执行一些额外的操作，例如权限控制、缓存、延迟加载等。</p><p>下面是一个使用代理模式的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject1</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RealSubject1: Handling request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject2</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RealSubject2: Handling request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProxy</span><span class="params">(Subject* subject)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在访问真实主题之前执行一些额外的操作</span></span><br><span class="line"><span class="keyword">if</span> (subject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;subject is nullptr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用真实主题处理请求</span></span><br><span class="line">subject-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在访问真实主题之后执行一些额外的操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RealSubject1 RealSubject1;</span><br><span class="line">RealSubject2 RealSubject2;</span><br><span class="line">Proxy proxy;</span><br><span class="line">proxy.<span class="built_in">setProxy</span>(&amp;RealSubject1);</span><br><span class="line">proxy.<span class="built_in">setProxy</span>(&amp;RealSubject2);</span><br><span class="line">proxy.<span class="built_in">setProxy</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">catch</span>(<span class="type">const</span> exception &amp; err) &#123;</span><br><span class="line">std::cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个主题接口（Subject），其中包含一个纯虚函数request()，用于处理请求。</p><p>然后，我们创建了一个真实主题类（RealSubject），它实现了Subject接口，并提供了真正的请求处理逻辑。</p><p>接下来，我们定义了一个代理类（Proxy），它也实现了Subject接口，并包含一个指向RealSubject对象的指针。</p><p>在代理类的request()方法中，我们在访问真实主题之前执行一些额外的操作（例如创建真实主题对象），然后使用真实主题对象处理请求，最后在访问真实主题之后执行一些额外的操作。</p><p>在main函数中，我们创建了一个代理对象proxy，并使用它来处理请求。代理对象会在访问真实主题之前执行额外的操作，并将请求传递给真实主题对象来处理。</p><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealSubject: Handling request.</span><br></pre></td></tr></table></figure><p>这个示例展示了代理模式的基本用法，它允许通过创建一个代理对象来控制对另一个对象的访问，并在访问对象之前或之后执行一些额外的操作。代理模式在需要对访问进行控制或添加一些额外的功能时特别有用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/09/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是指某个类有且仅有一个实例。为了不再增加其他实例，应做以下处理：</p><ol><li>构造函数私有化<ul><li>由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。</li><li>由于静态对象的访问权限是private，类外如果想要使用这个静态的单例对象，单例类中就需要提供一个public接口。类中只有它的静态成员函数才能访问其静态成员变量，所以这个单例类的public接口是一个静态函数。</li></ul></li><li>拷贝构造函数私有化或者禁用（ &#x3D; delete）</li><li>拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）</li></ol><p><strong>示例代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个单例模式的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="type">static</span> Singleton* m_obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">m_obj = <span class="keyword">new</span> Singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Singleton &amp;s) &#123;</span><br><span class="line">out &lt;&lt; s.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.c &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_obj = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Singleton *ptr = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">ptr-&gt;a = <span class="number">10</span>;</span><br><span class="line">ptr-&gt;b = <span class="number">20</span>;</span><br><span class="line">ptr-&gt;c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：类的静态成员变量在使用之前必须在类的外部进行初始化才能使用。</p><p><strong>存在的问题和改进</strong></p><p>​在调用getInstance()函数获取单例对象的时候，如果在单线程情况下是没有什么问题的，如果是多个线程，调用这个函数去访问单例对象就有问题了。假设有三个线程同时执行了getInstance()函数，在这个函数内部每个线程都会new出一个实例对象。此时，这个任务队列类的实例对象不是一个而是3个，很显然这与单例模式的定义是相悖的。</p><p>​使用锁机制可以解决上述问题，但是如果同时访问的线程过多会造成卡顿，此时就需要在加锁之前再加上一个判断，判断单例是否已被创建。如果已创建则无需进行后续操作，也就不需要加锁了（双重检查锁）。但是在单例未创建时还是会存在上述问题，所以最好在类加载的时候就对单例进行实例化（饿汉模式）。饿汉模式也有个缺点，就是如果单例并不会立即使用，则会浪费空间，但对于现代电脑来说，一点空间无关紧要。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
